- 准备步骤
		- 环境设置（基础）
	  		- ide的设置
		- 可以参考Get Started with C++ in Visual Studio Code，
	- GCC编译器（简介）
	  		- GCC的设置
		- 编译过程
		  			- 预处理
				- 读取程序的头部文件，结合头部文件与程序生成临时文件备用，
				- 调试选项
			- 编译
				- 将结合了头部文件的中间文件转换为汇编语言，输出到临时文件中备用，
			- 汇编
				- 根据CPU的具体类型调用对应的汇编器，将汇编语言转换为可执行的二进制代码，
			- 链接
				- 将多个二进制文件链接为一个可执行文件，
			-
		- C语言标准
		  			- C语言具有多个不同标准，包括ansi，C99，C11等，
			- 可以在编译时使用后缀来指定希望使用的标准，
		- 编译器警告
		  			- GCC可以检查程序中的可能错误，并在编译时发出警告，
			- 可以在编译时使用后缀来指定编译中遇到错误时的编译器行为，
		- 优化
		  			- GCC通过简化了部分编译步骤来优化最终生成的可执行文件，然而这些优化也使得源代码与机器码之间存在一定的差异，使得调试变得困难，
			- 可以在编译时使用后缀来选择需要的优化行为，
		- 调试
		- （make工具）
		- （GDB调试器）
- （字符集）
  	- 基本组成
	  		- 英文字母（26个大写和26个小写）
		- 十进制阿拉伯数字（10个）
		- 29种符号
		- 5种空白符号
		- 不可打印字符（null、警报、退格、回车）
			- 分别用`\0, \a, \b, \r`表示，
	- 源代码字符集
	- 运行字符集
- C程序的基本组成
  	- 一般的C程序包括三步：代码编写（code），编译（compile），执行（execute），
	- 代码编写
	  		- 包含需要的库
		  			- 为了使用对应的语句， 需要在程序开头引入对应的库——C语言并没有将所有函数都内置在语言的基本库中，
			- 语法为`#include<library.h>`，
		- 编写函数
			- main函数
			  				- 每个C程序都必须定义至少一个函数（且必须命名为main），
				- 语法为`int main(void)`，
					- 同数学函数一样，C函数需要参数（输入）和返回值（输出），
					- int表示函数返回（此处为向计算机*返回*，并非*输出*具体数值）的为整型数，
					- void代表main函数没有参数，
				- main函数会在程序开始执行时被首先调用，
			- 变量声明
			  				- 变量在使用前需要先声明（declaration），
				- 一般应先明确函数需要使用的变量，并将所有声明语句写在函数开始处，
				- 对于同一类型的变量，可以在一条语句中同时声明，即`int var1, var2;`，
			- 变量赋值
			- 其它函数
			  				- C程序中可以包含很多其它函数，这些函数会以子程序的方式被main调用，
				- 由于main被最先调用，而其它函数只能以子程序的方式被main调用；因此，理论上应先定义其它函数，在代码的最末尾再定义main函数，
				- 然而，可以通过代码开始处加入函数的“原型声明”，这样就可以将其它函数的定义写在main函数之后，
			- 结束函数
			  				- `return`语句表示函数的返回值，
				- （对于不产生返回值的main函数，不使用return语句也是合法的，但应养成使用return语句的习惯），
	- 预处理
	  		- 一般的C代码会以`#include`等语句作为开头，这些语句可以声明需要使用的库，或声明一些常量，
		- 这些语句会首先被预处理器处理，然后再传递给编译器，
	- 编译
	  		- （应首先将终端设置到文件对应的路径，如`cd /home/abc/Code`）,
		  			- 不同于windows，linux的路径区分大小写，
		- 利用编译器编译对应文件，一般为`gcc file.c`，
		- （可以使用`gcc -std = c11 file.c`语句来选择不同的C标准），
	- 执行
	  		- 在编译器内运行输出的可执行程序`./a.out`（应注意`./`符号），
			- 默认的输出文件为`a.out`，可以使用`gcc -o name file.c`将输出文件的名称改为`name`，
		- 如果程序存在错误，则编译器会报错；
		- 对于部分错误，编译器会生成可执行文件，但运行的结果可能与预期不符，
		- 对于部分错误，编译器不会生成可执行文件，
	- 代码运行
	  		- 编写代码，并保存为.c扩展名的文件，
	- （测试和调试程序）
- 编程语法
  	- 基本语法
	  		- C语言利用{}来标志函数的主体部分，
		- 语句的结尾需要使用分号；
		- C语言区分大小写，
	- 变量命名
	  		- 变量的名称应能够较好的表明变量的使用目的，
			- 可以使用小写、大写字母，数字和下划线，
			- 名称的第一个字符必须为字母或下划线，不能为数字，
		- 关键字和保留字符
	- 注释
	  		- `/*comment*/`表示注释，中间的内容会被编译器忽略；
		- 也可使用`//comment`表示注释，但这种注释只能写在行内（因为没有结束符号），
		- 由于注释会被编译器忽略，因此理论上注释可以写在代码的任何位置，
	- 字符串
	  		- 转义字符
			- 反斜`\char`后的字符代表其他含义（一般为难以用字符表示的含义），如`\n`为换行符，
		- 占位符
			- 百分号`%d`代表占位符（一般用于字符串中），在输出时，字符串中的占位符的位置会由指定的变量替代，
- 基本数据类型
	- 数据存储
	  		- 存储单位
			- 位(bit)
			  				- 计算机中最基本的存储单元，只能保存0或1两个结果之一，
			- 字节(byte)
			  				- 定义8位为一个字节，
		- 存储形式
		  			- 二进制
				- 16位（2字节）所能表示的最大有符号十进制整数为32767，无符号十进制整数为65535，
				- 32位（4字节）所能表示的最大有符号十进制整数为2147483647，无符号十进制整数为4294967295，
			- 浮点数
				-
		- 存储空间
			- “基本”数据类型的存储空间是不变的，
			- char为1个字节（8位)，
			- 一般int为4个字节，float为4个字节，long为8个字节；但其占用空间会随编译器的不同而变化，
			- 可以使用sizeof函数判断数据类型的大小，
		- sizeof函数
		  			- `sizeof(var1)`接受一个变量，返回指定类型占用的内存大小（以字节为单位），
			- 可以使用显式类型转换`(int)sizeof(var1)`将sizeof返回的值转换为int值，从而可以使用%d打印，
			- 如`(int)sizeof(char)`会返回1，即char变量占用1个字节，
	- 变量声明
	  		- 可以将声明语句和赋值语句写在一起，即`int num = 2;`是合法的，
		- 声明常量
		  			- 可以在代码的开始处使用`#define VAR1 value`将value赋值给VAR1，
			- 应注意语句中不需要赋值号=，
	- 数值
	  		- 整型数int
		  			- 其他整型数：short，long，long long，unsigned（只能存储正数），
			- unsigned int与int占用的存储空间相同，但是因为不需要存储负数，所以能表示的（十进制）数字的范围变大了一倍，
		- 浮点数float
		  			- 其他浮点数：double，long double（没有unsigned float类型），
			- 科学计数法：1.0e5表示1x10^{5}，2e-5表示2x10^{-5}，
			  				- 应注意1不能忽略，虽然数学中10^{5}和1x10^{5}相同，但1e5和e5在C中并不相同，
			- 将浮点数赋值给int类型不会报错，编译器会直接忽略数字的小数位（而不是四舍五入），
		- 复数
		  			- 包括`float _Complex, double _Complex和long double _Complex`类型，
			- complex.h文件包括了一些与复数相关的函数，
		- 数值溢出
		  			- inf值表示超出当前类型表示范围的值，
			- NaN值表示不符合函数运算规则的值（如向对数函数输入负值），
	- 字符char
	  		- 实质上，char类型存储的仍为数值，即字符在编码（如ASCII）中对应的整数；
			- 可以使用数值（八进制、十进制或十六进制）来给字符赋值，
			- 可以将字符的编码值通过数值的占位符（如%d）打印出来，
			- 可以用比较运算符对字符进行比较，如`'a' < 'z'`是合法的且为真（a的ASCII值为97，z的ASCII值为122），
		- char形式需要用单引号括起来，char形式也可以表示部分转义序列（如换行符`'\n'`），
	- 布尔值_Bool
	  		- C中的布尔值类型命名为_Bool，
		- `_Bool`实质上是一种整型数，0代表假，1代表真，
		- 若给_Bool类型赋值其它非零数值，则该变量会被设置为1，
	- 类型转换（cast）
	  		- 意义
		  			- 理论上，不同数据类型之间是不能进行运算的，
			- 然而，为了保证程序的运行，C规定了一些（隐式）类型转换规则，
			- 此外，也可以使用显式类型转换以进行运算，
		- 隐式转换
			- 类型级别
				- 基本级别（从高到低）：double, float, unsigned long, long, unsigned int, int（short和char类型默认会被转换为int），
			- 赋值语句中，表达式的数值会*先计算得到结果*，再将结果转换为设定的被赋值变量的类型（不管类型的级别高低），
			- 类型升级
				- short和char类型默认会被转换为int，
				- 对于两种不同类型的变量的运算，C会将两者转换为更高的类型，
			- 类型降级
				- 浮点数被转换为整型数时，小数点后的值会被直接舍去（不会四舍五入），
		- 显式转换
		  			- 使用`(type1) var1`可以将变量var1转换为type1类型，
	- 其他
	  		- size_t类型
			- sizeof函数的返回值为size_t类型，类似一个无符号整数，
- 高阶数据类型
	- 区别
	  		- 不同于基本数据类型，高级数据类型的存储空间是可变的；
		- 例如，存储HI的字符串需要用到2个字符和1个分界符（即总共3个字节），而存储BYE的字符串需要用到3个字符和1个分界符（即总共4个字节），
	- 数组array
	  		- 按*顺序*储存的一系列类型相同的变量，即变量可以为数值或字符；称数组中的变量为元素（element），
		- 数组的元素被依次存储在内存中相邻的位置，
		- 声明
		  			- 由于数组并非一个固定的类型，因此声明数组的方式也随着其包含的元素的种类的不同而变化，
			- 一般方式为`type array1[n]`，type为希望计入数组的变量的类型，array1为数组名称，n为分配给数组的可包含的元素数量，
		- 下标方法
		  			- 由于数组按顺序储存变量，因此可以通过整数下标访问存储进数组的元素，
			- 一般方式为`array1[n]`，
				- 使用数组中元素的方式基本类似使用变量，
				- 数组的索引从0开始，即最后一个元素的索引为n - 1，
				- 编译器不会检查下标是否正确，即编译器不会因错误的下标而报错，然而错误的下标可能导致程序无法达成想要的结果，
	- 链表linked list
		- 部分情况下，需要陆续的输入同一类数据——然而输入不同组数据的动作中间一般存在一定间隔，而这些间隔时间内，前面的数据的后面的内存位置可能被其他程序占用，
		- 理论上，可以将前面的数据整体复制一份，然后再在复制的数据后继续输入新的数据，然而前面的数据量很大时，复制那些数据可能会占用很多空间，
		- 因此，一般采用“链表”的方式处理陆续输入的数据——即保留原来的已经存储到内存中的数据，然后利用指针将后续的数据与已有的数据“链接”到一起，
	- 字符串string
	  		- “字符串”的本质为元素均为char类型的数组，
		- 基本语法为`char str1[n];`，
		  			- n代表分配给str1的字符个数；
			- C中的字符串以空字符`\0`为结尾（分界符），以在内存中区分不同的字符串，因此实际上str1可存储的最大字符数为n-1个，
			- 字符串需要用双引号括起来，
		- strlen函数
		  			- `strlen(str1)`返回字符串中的最后一个字符的下标（即字符串的长度），
			- strlen只能用于字符串（即字符组成的数组），不能用于数值组成的数组，
			- 虽然C用1字节存储一个字符，但sizeof返回的值一般和strlen返回的值不相同；因为strlen不会计入空字符（如单词间的空格），但这些空字符仍需要占用存储空间，
	- 指针
	  		- 当存储一个“数组”时，实际上存储的并非整个数组，而是数组的“位置”，
		- 例如，对于数组`array = int[20]`，变量`array`自身并非用了（20x4=）80个字节存储了数组中的每一个整型数，而只是存储了数组的开头数字在*内存*中的*位置*，
		- 这样，当后续语句调用array时，就可以去到内存中对应的位置，然后根据array的长度（80个字节）来逐个寻找需要调用的元素，
	- 结构
- 基本操作
  	- 赋值
	  		- 赋值运算
		  			- =表示赋值运算符，而不是数学意义上的相等，
			- 语句`var1 = n`的意思为将n赋值给var1，
			- 赋值的基本顺序为从右到左，从上到下，
				- 连续赋值运算`a = b = c = 123`是合法的，其含义为将123赋值给c，将c（123）赋值给b，将b赋值给a，
				- 然而这样的写法可能导致程序不易理解，实际编程时应避免，
		- 定义常量
		  			- 赋值时，在变量类型前加入const关键字（如`const int`）可以将变量定义为常量，
		- 赋值操作
		  			- “赋值”的实质为将数值存储到特定的内存位置上，
			- 左值指可用在运算符左侧的字符（例如数值123不能用作左值），可修改的左值（对象定位值）指没有用const关键字声明的左值，
			- 右值指可以赋值给左值的量，可以为变量、常量或表达式，
	- 复合赋值运算符
	  		- 递增运算++
			- 等同于加法运算`i = i + 1`,
			- 前缀`++ i`先将i的值加1，再使用i的值运算；后缀`i ++`先使用i的值运算，再将i的值加1，
		- 递减运算--（类似递增运算，）
		- 复合运算符只能影响“一个”变量，即`(i*j) ++`是无效的，
		- 复合运算符的优先级高于乘法，即`i * j ++`的含义为`i * (j + 1)`而不是`(i * j) + 1`，
	- 简化赋值运算符
	  		- 对于单变量的赋值和运算操作，可以简化赋值运算符，
		- 对于基本运算+、-、*、/、%，赋值运算`var = var + n`都可以简写为`var += n`，
		- 不同于复合赋值运算++，简化赋值运算符的优先级仍然为先进行代数运算，再进行赋值，
	- 基本运算（operator）
		- 算术运算符
		  			- 基本运算：+、-、*，
			- 除法运算
			  				- C中的除法只能在相同类型间进行，即整数/整数，浮点数/浮点数；若输入数据不是同一类型，则C会默认将其转化为浮点数/浮点数，
				- 整除运算`/`
					- 整数除法：C中的整数除法只会返回整数部分，小数部分会被直接舍弃（而不是四舍五入），如`5/3 = 1`，
					- 浮点数除法
				- 求余运算`%`
					- 求余运算符只能用于整数之间，返回两个整数相除得到的余数，
			- 运算顺序：类似数学运算，乘法优先级高于除法，
		- 指数运算函数`pow(a, b)`返回a^{b}，位于math.h头文件中，
		- 绝对值函数`fabs(a)`返回a的绝对值，位于math.h头文件中，
	- 布尔运算（关系运算）
	  		- 基本运算符
		  			- <（小于）>（大于）<=（小于等于）>=（大于等于）
			- `==`（等于）!=（不等于）
			  				- C中的等于和不等于可以比较字符，而并不局限于数字；但不能直接用于比较字符串，
				- 对于赋值运算符=，表达式`n = var1`是不合法的，因为不能给常量赋值；
				- 但对于比较运算符`==`，表达式`n == var1`是合法的；为了避免将比较错写为赋值，可以在比较时将常量写在左侧，
			- 浮点数比较
			  				- 由于浮点数的精度问题，不建议直接比较浮点数；
				- 一般方法为判断两个浮点数之间的差值是否足够小，如`fabs(float1 - float2) > 0.0001`（此处fabs为绝对值函数，位于math.h头文件中），
		- 运算优先级
		  			- 高优先级：<（小于）>（大于）<=（小于等于）>=（大于等于）
			- 低优先级：`==`（等于）`!=`（不等于），
		- 真值
		  			- 一般而言，C会将关系表达式运算的结果记为1（真）或0（假），
			- 在C中，任意的非0数值都会被当作真，只有0会被当做假，
	- 运算顺序
	  		- 由高到低：算数运算、关系运算、赋值运算，
			- 即`x = y > 2`的含义为`x = (y > 2)`，为赋值运算，而不是布尔表达式，
			- 若`y > 2`为真，则x会被赋值1，否则x会被赋值0，
			- y的值不会被赋值给x，
		- 大部分的运算符都是从左往右计算，
			- 类似数学运算，括号（）可以改变优先级，
			- 赋值=，递增++，递减--运算符从右往左计算，
- 复合语句
	- 局部变量
	  		- 应注意，在复合语句内部声明的变量（如常见的循环变量i等）的定义只*局限在复合语句内部*，即语句外的这些变量名是没有定义的，
		- 若想在复合语句外使用这些变量，则需要在复合语句外部声明这些变量，
	- 循环
		- while语句
		  			- 基本语法
				- `while (boolean) {statement}`，
				- while语句和布尔表达式的结尾*不需要*分号；标注，
					- `while (boolean); {statement}`会被解释为`while (boolean) {} ; {statement}`，即语句并没有被算入while循环中，
					- 理论上，可以将while语句`while (boolean) {statement1}`和其后面的语句`{statement2}；`合起来看作一个完整的以分号结尾的语句，
					- 然而，在while语句后直接结束函数也是合法的，
				- while语句不算一个完整的函数，因此需要写在函数内部，
				- while语句中主体部分的每个命题的结尾仍然需要分号；标注，
			- 运行逻辑
			  				- while语句的基本逻辑为`(boolean = T) →{statement} →(boolean = T) →{statement} →(boolean = T) →{statement} →(boolean = F) → out`，
				- 若布尔值一开始就为负，则while中的语句不会被执行，
		- do-while语句
		  			- 概述
				- 不同于基本的while和for语句，do-while语句会在循环的每次迭代之后检查测试条件，
				- 换言之，循环体中的语句至少会被执行一次，
			- 基本语法
				- `do{statements} while (boolean);`，
				- 理论上，用while循环也可达到同样的效果，即`statements;  while (boolean){statements}`，do-while语句简化了上述代码，
		- for语句
		  			- for语句类似while语句，其功能也是重复执行某些语句；但for循环一般比while语句更加简约，
			- 语法对比
			  				- 一个基本的循环可以分为三步：初始化计数变量，判断循环条件（并执行语句），更改循环条件，
				- while语句的基本语法为`int i = 1; while(i < num){statement; i++;}`
				- for语句则可简写为`for(int i = 1; i < num; i++){statement}`，
			- 基本语法
			- 具体语法
			  				- for语句的圆括号后的三个表达式分别对应了循环的三个基本步骤：初始化计数变量，判断循环条件，更改循环条件，
				- 应注意表达式之间需要用分号分隔开，
				- 第一个表达式
				  					- 第一个表达式一般是初始化循环变量，但也可以是其它需要进行的操作——只要是合法的语句即可，
					- 不管第一个表达式是什么，该表达式都只会在for循环开始之前被*执行一次*，
				- 第二个表达式
				  					- 第二个表达式一般是循环条件，
					- 循环条件可以是复合命题，如`(var1 * var2 -var3 < num)`——理论上，只要结果可以解释为布尔值即可，但应注意避免无限循环，
				- 第三个表达式
				  					- 第三个表达式一般是更改循环条件，
					- 常见的更改为将i递增（递减）1，但也可以为其它任意合法的表达式，
			- 逗号运算符
			  				- 逗号一般作为分隔符使用，但也可以用于分隔两个表达式，一般用于for循环中，
				- 对于`(statement1, statement2)；`，
					- 先*运算*statement1，
					- 再（从左到右）运算statement2，
					- 最后*输出*（返回）statement2的值，
		- 循环一般与数组配合使用，
		  			- 例如，可以将循环变量i设置为数组的索引，从而利用循环遍历数组，
	- 选择
		- if语句
		  			- 基本语法为`if(boolean){statement}`，
			- 同while语句一样，if标识词和布尔表达式的结尾*不需要*分号；标注，
			- 若布尔值为真，则执行statement；否则跳过statement，执行后续代码，
			- （if语句可以不附带else语句），
		- if-else语句
		  			- 基本语法为`if(boolean){statement1} else {statement2}`，
			- 由于布尔值*只有真、假两种*可能，因此布尔值为真时，statement1会被执行；若布尔值为假，则statement2会被执行，
			- 因而else标识词后*不需要*布尔表达式`(boolean)`，
			- if-else语句为一个整体，即`{statement1}`和`else`之间不能插入其它语句；应将所有需要执行的语句都同statement1一起写在if后的花括号内，
			-
	- 嵌套循环
		- 对于较复杂的行为，可能需要多个循环的组合才能描述，
		- 可以写流程图来辅助分析，例如，对于嵌套循环
其代表的意思为
	开始第一个for循环
				  					- 初始化i = 1，
					- 判断条件i < num1，
					- 条件为真时执行statement1，
					- 执行第二个for循环，
					  						- 初始化j = 1，
						- 判断条件j < num2，
						- 条件为真时执行statement2，
						- 递增j ++，
						- 再判断条件j < num2，条件为真时重复，
						- 直到条件为假，跳出循环，
					- 执行statement3，
					- 递增i ++，
					- 再判断条件i < num1，条件为真时重复，
				- 直到条件i < num1为假，跳出循环，
		- 一般情况下，嵌套循环可以理解为外部循环每进行*一次*，内部循环都会执行*一整轮*，
- 函数
	- 自定义函数
	  		- 基础
			- 基本语法为`type func(type arg1, type arg2, ...){statement}`，
			  				- 同数学函数一样，C函数需要参数（输入）和返回值（输出），
				- 输出
					- 最开始的`type`表示函数返回的数值类型，
					- 若没有返回值，则应使用`void`，
				- 输入
					- 括号中的`type arg1, type arg2, ...`代表函数接收的参数，
					- 定义参数时应注意，参数也需要声明具体类型，
					- 若没有参数，则应使用`void`
						- 理论上也可以不写，即空括号（），
				- `func`为函数名称，
				- 函数执行的具体行为应写在{}中，
			- 参数
			  				- 形参（parameter）与实参（argument）
				  					- 形参（formal parameter）指“形式”上的参数，即用代词表示的函数可以接受的参数，即函数定义中的arg1，
					- 实参（actual argument）指“实际”上的参数，即用户使用函数时具体输入的数值，
					- 程序运行时，函数会接受“实参”，并将其传递给“形参”，然后运行函数，
				- 函数内参数
				  					- 在函数内定义的参数仅限于函数内，即不会与函数外定义的相同名称的参数产生冲突，
				- 参数数量（可变数量参数）
			- 函数原型声明
			  				- 预处理器声明
				- main后置函数声明
				  					- 由于main被最先调用，而其它函数只能以子程序的方式被main调用；因此，理论上应先定义其它函数，在代码的最末尾再定义main函数，
					- 然而，可以通过代码开始处加入函数的“原型声明”，这样就可以将其它函数的定义写在main函数之后，
					- 一般方式为在main语句前输入`type func(type arg1, type arg2, ...);`，
						- 此处不需要写出函数的具体语句，
						- 应注意定义函数时不需要分号；但声明函数时需要加上分号；
			- 规则
			  				- 函数的定义不能嵌套在另一个函数的定义中，
	- 基本输出函数
	  		- printf函数
			- 基本语法
			  				- `printf("string", var1, var2...)`，
				- printf函数接受的主要参数只能为*单个字符串*（即"string"），或字符串变量（如str = "string"），
				- 需要使用占位符来输出其他变量（整型数，嵌套字符等），
			- 占位符
				- 百分号`%`代表占位符，在输出时，字符串"string"中的占位符的位置会由指定的变量替代，
				  					- 可以使用`%%`来输出百分号，
				- 变量标记符（Specifiers）
					- 数值
						- 基本：`%d`接受int值，`%f`接受float值，short，long，long long，unsigned分别也有对应的指代，
						- 数字进制：对于同一整型数，%d可以显示十进制数字，%o和%x则会分别显示对应的八进制和十六进制数字，
						- 科学计数法：使用%e可以将对应数值按科学计数法输出，
					- 字符
					  						- 对应占位符为`%c`，
					- 字符串
					  						- 如果需要输出多个字符串，或将字符串变量嵌入语句中，则需要使用占位符`%s`，
				- 修饰符（modifiers）
					- 在%和变量标记符可以插入修饰符（数字或字母），
					- 例如，`%05.2f`表示打印一个浮点数
					  						- 5表示最小字段宽度为5字符，0表示数值有空缺时（此处为不到5位），用0补齐位数（不输入0则会用空白补齐），
						- .2表示小数点保留2位（精度），
						- f为浮点数的标记符，
				- 标记符（flags）
				  					- 在%和变量标记符可以插入标记符（符号或空格），
					- 例如，加入#号`%#x`则可以在进制数前显示表示进制的前缀，
				- 备注
				  					- 对于printf函数而言，不同的占位符表示指代的为数据的不同*显示*方式，并非数据的*存储*方式，因此同一字符可以输出为不同“格式”，
					- 例如，字符C会按照ASCII码存储为二进制`01000011`，使用%c会将其显示为C，使用%d会将其显示为67，而使用%o则会将其显示为103，
			- （printf函数不会加入换行符，因此一般在字符串末尾加入换行符以方便下一行输入），
	- 基本输入函数
	  		- scanf函数
		  			- 变量声明
			  				- 在使用scanf函数接受输入之前，应先声明需要用到的变量，
				- scanf是直接将输入赋值给指定的var1，因此不能与声明语句放在一起（如`var1 = scanf("%s", var1);`），
			- 基本语法
			  				- `scanf("string", &var1);`会在终端中提供一个空行以供输入，并将“输入”赋值给var1，
				- 类似printf，scanf函数接受的主要*参数*仍然只是*单个字符串*（即"string"），
				- 应注意双引号“”和*&符号*（作为对比，printf中不需要&符号），
				- 输入字符串时不需要加入&符号，基本语法为`scanf("%s", str1);`，
			- 返回值
			  				- scanf的返回值为成功赋值的变量的个数（一般为正整数），可以赋值给int变量，
				- 若检测到的输入类型与占位符的类型不符合，则scanf不会读取输入并会返回数值0，
				- 若遇到其他错误，scanf会返回EOF值，通常被定义为-1，
			- 占位符
			  				- 类似printf函数，scanf函数和也需要利用占位符%来声明输入的变量的类型，
				- scanf函数所使用的占位符与printf相同，如%d代表整型数，%f代表浮点数，
				- 应注意char对应的占位符%c会将数值1表示为字符'1'，
			- 多个输入
			  				- scanf以空白（空格、换行符等）为分隔，将输入的字符串中以空白分隔开的字符逐个赋值给多个变量，
				- 如`scanf("%d %f", &var1, &var2);`会将`1 2`分别赋值给`var1 var2`，
				- 由于scanf以空白（空格、换行符等）为分隔，因此scanf不会读取以空格分隔的整个字符串，而只会读取第一个词，
	- 其它基本函数
	  		- 字符函数
			- getchar函数
			  				- getchar函数返回命令行中输入的下*一个*字符，返回一个字符变量，
				- 基本用法为`char ch = getchar();`，这等同于`scanf("%c", &ch);`，但getchar函数只处理一个字符，因此速度更快，
			- putchar函数
			  				- putchar函数接受*一个*字符变量，并将其打印出来，
				- 基本用法为`putchar(ch);`，这等同于`printf("%c", ch);`，但putchar函数只处理一个字符，因此速度更快，
				- （putchar函数不会加入换行符），
			- 多次调用
				- 虽然getchar和putchar函数一次只会处理一个字符，但是两者可以被多次调用，
				- 即`ch1 = getchar(); ch2 = getchar(); ch3 = getchar();`会按顺序将命令行中输入的前三个字符分别赋值给ch1、ch2、ch3；
				- 而`putchar(ch1); putchar(ch2); putchar(ch3);`则会按顺序将ch1、ch2、ch3逐个打印出来，
- 高阶操作
  	- 声明
	- 内存管理
	- 文件管理
- 库

```
for(int i = 1; i < num1; i++){
	statement1;}
	for(int j = 1; j < num2; j++){
	statement2;}
	
	statement3;
	}
```
-
-
-
-
-
-
- 其它
- [[Data_science]]