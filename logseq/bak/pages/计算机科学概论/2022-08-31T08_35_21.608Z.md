- 硬件
	- 电路
		- 门电路
			- 定义
			  collapsed:: true
				- 门（逻辑门）是对电信号执行基本运算的设备，接受一个或多个输入信号，只输出一个信号，
				- 可以使用布尔代数，逻辑图或真值表来表示门电路，
			- 分类
			  collapsed:: true
				- 基本门电路有三种，非（NOT），与（AND），或（OR），
					- 与门和或门可以接受多个输入，
				- 由这三种门可以构造出其它的电路，如异或（XOR），与非（NAND）和或非（NOR），
		- 晶体管
		  collapsed:: true
			- 由半导体材料制成，可以根据电流的强度改变电阻，从而在传导电流和阻止电流之间转换，
			- 晶体管有三个接线端：源极（Source），基极（Base），发射极（Emitter），
			  collapsed:: true
				- 源极默认输出高电压，发射极接地，
				- 如果基极输入的是高电压，则将源极接地，从而晶体管没有输出；这就是非门的工作原理，
				- 反之则不将源极接地，从而晶体管输出源极电压（高电压），
				- 按照这样的逻辑，与非（NAND）和或非（NOR）需要两个晶体管才能构造，
				- 而与门和或门则需要三个晶体管（即两个用于与非门，一个用于非门），
				- ![image.png](../assets/image_1661934408049_0.png)
		- 电路
			- 由基本门电路组合而成，可以执行更复杂的任务；一般分为两类，
			- 组合电路：输出仅由输入值决定的电路，
			- 时序电路：输出由输入值和电路当前“状态”
		- 集成电路
			- 由晶体管组成的电路，
			- 在一个很薄的平面硅片内，包含了电路板的所有部件与布线，
			- （摩尔定律）
	- 数据
	  collapsed:: true
		- 数据的表述
		  collapsed:: true
			- 模拟（analog）信号与数字（digital）信号
			  collapsed:: true
				- 模拟信号
					- 连续信号，即数值的变化是“平滑”的，
					- 一般认为自然界中的变化都是连续的变化，如水的流动，温度的升降等，
					- 部分人工事物也为连续的变化，如汽车的速度表盘，酒精温度计的度数等（虽然不能“读”出连续的数值，但我们认为其变化是连续的），
				- 数字信号
					- 离散信号，即数值的变化是跳跃的，
					- 相比于模拟信号，数字化的数据可以用多种方式来存储、传输和处理，
		- 计算机容量
		  collapsed:: true
			- 计算机的容量等概念一般都由2的幂次表达，
			  collapsed:: true
				- 一般2^{10}(1024)近似于10^{3}(1000)，
			- 比特(bit)
				- 表示数字信息的最基本单位，只有0，1两种可能取值，
				- 一般用 0 表示“关”（False），用 1 表示“开”（True），
			- 字节(byte)
				- 数据处理及内存组织的基本单位，由8个比特组成，
				- 可知，一个字节可以编码256(2^{8})个不同的二进制值，这也是ASCII对应的基本字符集，
				- 更全的字符集（Unicode）使用两个字节（65535(2^{16})个不同的二进制值）来编码字符，
				- 计算机以不同大小的块为单位操作数据的，如64 位指的就是计算机所能访问的内存地址的最大的“块”的大小，
		- 数字的表示
		  collapsed:: true
			- 二进制与数字进制
			  collapsed:: true
				- 二进制与十进制的转化
				  collapsed:: true
					- 十进制数值实际上是 10 的某次幂之和的简写，二进制数（和其它进制）同理，只不过基数是 2，
					- 转换为十进制(base k)
					  collapsed:: true
						- abc = a ⋅ k^{ 2} + b ⋅ k^{ 1} + c ⋅ k^{ 0}，
						- 110(base 2) = 1 ⋅ 2^{ 2} + 1 ⋅ 2^{ 1} + 0 ⋅ 2^{ 0} = 4 + 2 + 0 = 6，
						- 234(base 16) = 2 ⋅ 16^{ 2} + 3 ⋅ 16^{ 1} + 4 ⋅ 16^{ 0} = 512 + 48 + 4 = 564，
						- 2CD(base 16) = 2 ⋅ 16^{ 2} + C(12) ⋅ 16^{ 1} + D(13) ⋅ 16^{ 0} = 512 + 192 + 13 = 564，
					- 由十进制转换(base k)
					  collapsed:: true
						- 示例
						  collapsed:: true
							- 二进制
							  collapsed:: true
								- 25 // 16(2^{ 4}) = 1，a_{ 1} = 1；
								- number = 25 - 1 ⋅ 16 = 9，i = i - 1 = 3，
								- 9 // 8(2^{ 3}) = 1，a_{ 2} = 1；
								- number = 9 - 1 ⋅ 8 = 1，i = i - 1 = 2，
								- 1 // 4(2^{ 2}) = 0，a_{ 3} = 0；
								- number = 1 - 0 ⋅ 4 = 1，i = i - 1 = 1，
								- 1 // 2(2^{ 1}) = 0，a_{ 4} = 0；
								- number = 1 - 0 ⋅ 2 = 1，i = i - 1 = 0，
								- 1 // 1(2^{ 0}) = 1，a_{ 5} = 1；
								- number = 1 - 1 ⋅ 1 = 0，i = i - 1 = -1，
								- 25 = 11001(bin)
							- 十六进制
							  collapsed:: true
								- 63 // 16(16^{ 1}) = 3，a_{ 1} = 3；
								- number = 63 - 3 ⋅ 16 = 15，i = i - 1 = 0，
								- 15 // 1(16^{ 0}) = 15(F)，a_{ 2} = F；
								- number = 15 - 15 ⋅ 1 = 0，i = i - 1 = -1，
								- 63 = 3F(hex)
						- 输入：十进制数number
						  collapsed:: true
							- i = 1
							- while number - k^{ i} > 0
								- i = i + 1
							- return i  - 1
								- 示例：25 - 16(2^{ 4}) > 0; 25 - 32(2^{ 5}) < 0; return i = 5 - 1 = 4,
							- while number > 0
								- a_{ 1} = number // k^{ i}
								- number = number - a_{ 1} ⋅ k^{ i}
								- i = i - 1
						- 输出：k进制数a_{ 1}a_{ 2}a_{ 3}…
				- 十六进制
				  collapsed:: true
					- 二进制的数值较长，一般不易于人为处理，
					- 因此部分信息采用十六进制的方式表示，如颜色信息，
			- 负数的表示
			  collapsed:: true
				- 二进制补码（complement）
				  collapsed:: true
					- 目前使用的表示法为二进制补码，
					- 同样，使用后7位表示0-127之内的（正）数，首位为0，
					- 若首位是1，则使用进一位的二进制数1 0000 0000减去该数字，得到的数值的负数为对应数字，
					  collapsed:: true
						- （也可以将该数字转换为十进制，再减去256（1 0000 0000），得到的负数为对应数字），
					- 在该计数标准下，将当前数字（无论正负）的二进制表示按位取否后加1，即为当前数字的相反数的二进制表示，
					  collapsed:: true
						- 直接按位取否，正数n对应的为-(n + 1)，而负数-n对应的为+(n - 1)，
						- 即NOT 6 为 -7，NOT -7 为 6，
			- 浮点数（float）
			  collapsed:: true
				- 小数位的转换
					- 类似于用除法转换整数，
					- 对于小数，需要用新的基数乘以小数，乘法的进位为对应的首位二进制小数，
					- 对剩余的小数重复上述步骤，
				- 示例
					- 部分小数有对应的二进制小数，
						- 0.75 * 2 = 1（进位）.50
						- 0.50 * 2 = 1（进位）.00（小数为0，结束运算），
						- 所以0.75 对应小数 0.11，
					- 部分小数则没有准确对应的小数，
						- 0.33 * 2 = 0（进位）.66
						- 0.66 * 2 = 1（进位）.32
						- 0.32 * 2 = 0（进位）.64
						- 0.64 * 2 = 1（进位）.28
						- ……
						- 所以0.33对应小数0.0101…，
		- 字符
		  collapsed:: true
			- 字符集（character set）通过指定字符与数字的一一对应，可以将字符也用数字的形式表示出来，
			- ASCII
			  collapsed:: true
				- 包括了26个英语字母的大小写，以及出现在文本中的符号（包括基本的标点符号，空格等），
				  collapsed:: true
					- 基本的qwerty键盘上的所有字符都有对应的表示方式，
				- 由于8位二进制数可以表示0-255内的整数，所以ASCII中提供了256个字符的表示法，
				  collapsed:: true
					- 因此，字符可以用一个字节存储，
				- ASCII字符表一般用十进制表示，但其在计算机中仍以二进制存储，
			- Unicode
			  collapsed:: true
				- 为了加入更多的字符，Unicode采用更多二进制数设置了字符集，
					- 一般每个字符都为16位，但也有更多位的表示，
				- Unicode字符表一般用十六进制表示，
		- 声音
		  collapsed:: true
			- 采样
			  collapsed:: true
				- 周期性的测量信号的电压，并记录对应的数值，
				- 一般采样率在每秒40000次左右，就足以创建合理的声音复制品，
			- 音箱，耳机等设备将这些离散的数字信息重新转化为声波并播放出来，
		- 图像
		  collapsed:: true
			- 传感器将外界的连续的图像分割为大量的离散的像素点，
			- 每个像素点都由三种基本颜色（红，绿，蓝）的组合来表示其颜色；每个颜色的具体取值称为“色深度”，
			- 光栅图形格式按照像素点逐个存储图像信息，
			- 矢量图形则使用线段和其它几何形状描述图形，矢量图存储的不再是像素点和色深，而是描述几何图形的方向，线宽等的代码，
			- 显示器将这些离散的像素点组合起来重新形成图像，
		- 视频
		  collapsed:: true
			- 视频的实质为连续播放的图像和配套的声音，
		- 数据压缩
		  collapsed:: true
			- 概述
				- 压缩的目标是把相同信息编码成更少的比特或位。
				- 所有压缩算法的思路都是减少或去掉那些不能物尽其用的位串，采用的主要方法包括把出现频率较高的元素编码成短位串、构造频率字典、用数字代替重复内容等。
				- 压缩时也可能需要权衡其他因素，如压缩速度和复杂性与解压速度和复杂性。
				- 不管是什么压缩算法，有些输入都是无法被压缩的，
			- 无损压缩
				- 字符编码
				- 可以用更少位来表示那些常见字母，而必要的情况下用较多位表示那些不常见字母。这样总的位数就可以显著减少。
			- 有损压缩
				- 一些情况下，并不需要准确重现原始输入，解压后的结果只要大致差不多就足够了。这时使用有损压缩可以得到更好的效果，
				- 图像压缩
					- JPEG 算法利用感知编码，将常见图像压缩到十分之一或更小，但看上去也不会明显失真。
					- 生成 JPEG 图像的大多数程序都允许控制压缩率，
				- 视频压缩
					- MPEG 系列算法中，视频的单独一帧可以用 JPEG 压缩，
					- 此外，还可以把连续的、变化不大的一系列帧压掉一部分。或者通过预测画面运动结果，只编码变化部分，甚至把运动的前景从静止的背景里分离出来，减少背景占用的位数，
				- 音频压缩
					- MP3 是一个用来压缩声音的感知编码方案。
					- MP3 利用了人耳无法听到 20 kHz 以上频率，明亮的声音会掩盖轻柔声音等事实。可以把标准 CD 音频压缩到原来的十分之一大小。
		- 综上所述，以上的信息都可以使用数字表示，因此可以使用计算机来处理，
	- 计算结构
	  collapsed:: true
		- 图灵机
		  collapsed:: true
			- 英国数学家艾伦·图灵证明，一个非常简单的计算机就能够计算任何可以计算的任务，
			- 在不考虑速度和存储器容量的前提下，所有计算机的“能力”是等价的，
		- 冯·诺依曼体系结构
		  collapsed:: true
			- 冯·诺依曼认为，计算机应“包含主要元件用于运算、存储数据、控制以及连接操作人员”，
			- 对于目前的计算机，CPU提供运算和控制功能，内存和磁盘用于存储数据，键盘、鼠标和显示器用于连接操作人员，
			- 计算机的逻辑结构自冯·诺依曼之后并没有太大改变，但物理结构已经发生了巨大变化，主要表现为摩尔定律导致的集成电路的更新，
		- CPU（中央处理单元）
		  collapsed:: true
			- 时钟频率
			  collapsed:: true
				- CPU 通过内部时钟来控制基本操作的节拍，
				- 内部时钟每秒的振动次数可以度量 CPU 速度，
			- CPU的指令表
			  collapsed:: true
				- 任何计算都可以分解为能使用基本指令完成的小步骤。
				- 包括算术运算、比较数据、基于前置计算结果选择下一条指令，
				- CPU 能根据它所处理的数据决定下一步做什么，因此它就能自己运行整个系统，
			- 累加器
			  collapsed:: true
				- 保存用户最近输入的数值，或者最近计算的结果，
				- 现代的CPU一般有多个累加器，即可以保存多个计算得到的中间数值，
			- 缓存（cache）
			  collapsed:: true
				- 通常CPU执行一条指令只需要1纳秒，而从RAM中取得数据或指令大概要花 50 纳秒，
				- 因此现代计算机会在 CPU和 RAM之间使用小容量的高速存储器来保存最近使用过的指令和数据，称为缓存，
				- 最近用过的信息很可能再次被用到，而把它们存储在缓存里就意味着减少对 RAM 的等待，
				- 典型的 CPU 有两到三个缓存，容量依次增大，但速度递减，
			- 并行处理
		- 存储设备
		  collapsed:: true
			- RAM（随机访问存储器）
			  collapsed:: true
				- “随机访问”，指CPU以任何顺序随机访问不同位置时，速度不会受到影响，
				- 内存是易失性的，也就是掉电之后里面的内容会消失，
				- 每个 RAM 位置可以保存一个数值或一条指令，这样就可以在 RAM 中保存由指令和数据共同组成的程序，
				- CPU可以从RAM中取得要操作的数据，然后再把结果保存到 RAM，
			- 硬盘
			  collapsed:: true
				- 大容量存储器能在掉电后仍保存着里面的信息，
				- 硬盘里的硬件电路和操作系统里称为文件系统的软件一起创建了现有的文件结构，
				- 机械硬盘
				- 固态硬盘
	- 嵌入式系统
	- 分布式计算
	  collapsed:: true
		- 如果能把大任务分解成小任务，而分解后的小任务又可以通过不同 CPU 协作完成，CPU 相互之间不会出现太长的等待，也不会有太多的相互干扰，那么就能以这种方式加快完成大任务，
		- 分布式计算指的是很多更加独立的计算机（比如不共享内存），而且地理上更加分散，
- 软件
	- 计算机语言
		- 机器语言
		  collapsed:: true
			- 即内置在计算机电路中的指令，只由二进制数字0，1组成，
			- 机器语言是所有程序在计算机上运行时采用的最终形式，
		- 汇编语言
		  collapsed:: true
			- 汇编语言通常与 CPU 的指令一一对应，能够以特定方式将指令编码为二进制格式，也知道信息在存储器中如何存放。
		- 高级语言
		  collapsed:: true
			- 用高级语言编写的代码更加类似自然语言，而且独立于硬件的体系结构，即可在不同的硬件结构上运行，
			- 将高级语言转换为机器语言的程序被称为编译器，
		- 结构化语言
		  collapsed:: true
			- 类型
			  collapsed:: true
				- C（1970）：编写汇编器、编译器、编程工具乃至操作系统等工具，
				- C++（1980）：定位是应对大型程序开发过程中的复杂性，
				- Java（1990）：最初的目标是开发小型嵌入式系统，例如家用电器和电子设备中的系统，因此对速度要求不高，但对灵活性的要求很高，
				- Javascript（1995）：最初的设计意图是在浏览器中实现网页的动态效果，
				- 现在的编程语言多达几千种，每种语言都代表了对效率、表达力、安全性和复杂性的取舍，
			- 基本概念
			  collapsed:: true
				- 编程语言的某些基本概念是相通的，因为这些概念都是为了表达一系列计算步骤而发明的。
				- 基本的步骤包括获得输入，进行计算，显示输出；复杂的则包括存储计算值，根据计算值决定下一步等，
		- 面向对象设计
		  collapsed:: true
			- 函数库
			  collapsed:: true
				- 函数库通过 API（Application Programming Interface，应用编程接口）的形式描述给程序员，
				- API 会罗列出所有函数，说明每个函数的用途、用法、需要的输入数据，以及生成什么值。
				- API 也会描述数据结构，即数据的组织形式，
				- 大型系统开发通常都会用到 SDK（Software Development Kit，软件开发工具包），以便程序员在极其复杂的软件库里找到有用的函数，
		- 数据结构
		- 算法
		  collapsed:: true
			- 算法是忽略具体实例而对过程进行的一种抽象或理想化的描
			  述，
			- 算法的每一步都表达为一种基本操作，其含义是完全确定的，没有歧义，
			- 算法的一个关键属性是其效率有多高，
			- “P”（即“Polynomial”，多项式），因为它们可在多项式时间内解决，
			- NP 的意思是“非确定性多项式”（nondeterministic polynomial），我们还不知道对这类问题有没有多项式算法，
			- 在大多数情况下，一个近似的解决方案可能就足够好了，而能够给出合理近似答案的算法较多，
	- 操作系统
	  collapsed:: true
		- 概述
		  collapsed:: true
			- 引入
			  collapsed:: true
				- 最初的计算机的能力非常有限，每次只能运行一个程序，即这个程序会接管整台机器，
				- 随着硬件越来越强大，越来越复杂，为了有效地使用这些部件，最好可以同时运行多个程序，
				- 一种方式为用程序来管理程序，这样的程序就是操作系统，
			- 演化
			  collapsed:: true
				- 操作系统也是一种程序，也是同一类编程语言编写的，最常用的是 C 和 C++，
				- 最早的操作系统每次只运行一个程序，也没有太多内存可供分配，Unix 操作系统在 1975 年的时候是一个包含 9000 行 C 代码的汇编程序；
				- 今天的操作系统已经非常庞大（包含数千万行代码），它们是几千人历经几十年工作的成果，
			- 种类
			  collapsed:: true
				- Windows是最常见的操作系统，
				- 苹果电脑运行的 macOS 是一种 Unix 变体，iOS 源自 macOS，
				- Android是精简版的Linux系统，
				- 做幕后工作的计算机运行的是 Unix 或 Linux，
				- Linux 非常稳定、容易修改、方便移植，而且免费。
				- 相对而言，自己开发一个专有系统，或者取得某个商业系统的许可，都会引入巨大开销；而且也要考虑后续的软件开发的情况，
		- 启动（booting）
		  collapsed:: true
			- 现代的CPU有特殊的设计，可以在计算机加电后主动执行存放在硬盘中的少量指令，
			- 这些指令会找到更多指令并继续运行，
				- 一般为存储在磁盘上的指令，也可能存储在USB 存储器或网络连接的既定位置上，
				- 指令包括对硬件（内存等）和输入输出设备的检查，驱动程序的加载等，
			- 随着指令的级联运行，整个操作系统会最终启动，
			- 操作系统的“启动”的基本思想就是少量指令找到更多指令，后者再找到更多的指令，
		- 功能
		  collapsed:: true
			- 控制和分配计算机资源
			  collapsed:: true
				- CPU的管理
				  collapsed:: true
					- 将一个暂时等待的程序（比如等待用户在上面单击的对话框）挂起，
					- 阻止个别程序多占资源等，
				- RAM的管理
				  collapsed:: true
					- 把程序加载到内存中以便执行指令；
					- 确保不同的程序相互分离、互不干扰，即一个程序不能访问分配给另一个程序或操作系统自身的内存，
					- 为了有效利用 RAM，一种思路是在必要时把程序的一部分加载到 RAM，而在程序处于非活动状态时再把它转存回磁盘，这个过程称为交换（swapping），而这部分磁盘被称为“虚拟内存”，
				- 硬盘的管理
				  collapsed:: true
					- 文件系统负责提供计算机中的文件夹和文件的分层机制。
				- 输入/输出设备的管理
				  collapsed:: true
					- 维护屏幕上的多个窗口，确保每个窗口都能显示正确的信息，而且在这些窗口被移动、缩放或隐藏后再次显示时，都能准确地恢复原貌，
					- 将键盘和鼠标的输入送往需要这些输入的程序，
			- 运行
			  collapsed:: true
				- 操作系统会依次将硬件的控制权分配给准备运行或需要关注的每个应用程序，
				- 同时对（后台）事件做出响应，
			- 系统调用
			  collapsed:: true
				- 操作系统提供了一个平台，使得程序可以更好的调用计算机的硬件，因此为操作系统构建应用程序会变得更加简单，
				- 操作系统定义的基本操作（服务）包括将数据存储至文件或者从文件中取出数据、建立网络连接、获取键盘输入、报告鼠标移动和按钮点击、绘制屏幕等等，
				- 操作系统的这些“入口”被称为系统调用（system call），
			- 设备驱动程序
			  collapsed:: true
				- 不同的外接设备有不同的配置，
				- 操作系统通过驱动程序的接口以统一的方式访问设备，这使得操作系统更容易处理不同的设备，
				- 因此，操作系统发送会发送通用的请求，而设备对应的驱动程序则会将这些请求转化为设备可以执行的操作，
				- 目前的多数设备的接口都是标准化的，所以其驱动程序已经内置在操作系统内，而驱动设备的特殊程序也已经包含在设备自身的处理器中，
			- 硬盘文件系统
			  collapsed:: true
				- 概述
				  collapsed:: true
					- 计算机有逻辑组织和物理实现两大概念，文件系统就是这两大概念的集中体现，
					- 文件系统会将硬盘看成大量由一定字节组成的“块”，再将信息分块储存，
					- 文件系统不会在同一个块内存储不同文件的信息，因此存储每个文件的最后一个块不会完全用完，
					- 兆字节级别的文件需要占用上千个块，这些块一般不是连续的，而是会分散在磁盘的各个地方，
				- 文件
				  collapsed:: true
					- 创建
					  collapsed:: true
						- 应用程序在创建新文件时会向文件系统发送请求，
						- 文件系统会在相应的文件夹中增加一个新条目，包含文件名、日期等项，还有文件大小为零（因为还没有为这个新文件分配磁盘块）
						- 应用程序要向文件中写入某些数据时，文件系统会找到足够多的当前没有使用的或者“空闲”的块来保存相应内容，并把数据复制过去。然后把这些块插入到文件夹的块列表中并返回给应用程序，
					- 访问
					  collapsed:: true
						- 路径是访问文件的基本方式，文件系统会从其顶级层次开始搜索该文件，在相应文件夹里查找文件路径中的每一部分，
						- 实践中，应用程序和操作系统会记住当前的文件夹，因而文件系统不必每次都从顶层开始搜索，
					- 删除
						- 一般删除文件时，文件系统会将文件占用的块移动到空闲列表，再将文件夹中该文件的条目清除，
						- 文件系统不会主动重写这些块中的内容，但是由于这些块被设置为空闲，因此其他应用程序创建文件时，这些块的信息会被覆盖，
						- 因此，硬盘中的内容可能能被恢复，
						- 文件系统提供了一些其它删除选项，一种方式为先用随机生成的比特重写块的内容，再将块设置为空闲，
						- 对于文件的路径信息，文件系统可能只会让相应文件夹条目不再指向有效的文件，而不是彻底清除路径信息；这样如果需要恢复文件，实现起来会简单很多，
				- 文件夹
				  collapsed:: true
					- 从存储方式上讲，文件夹等同于文件，其内容是文件夹和文件的位置信息，
					- 文件系统保留了自己管理和维护文件夹内容的权限，用户和软件只能请求文件系统来间接地修改文件夹内容，
					-
			- 其他文件系统
			  collapsed:: true
				- CD，DVD，USB和SD卡等移动存储设备同样有对应的文件系统，但实现的细节上存在一定差别，
				- 这些移动设备的文件系统通过软件与计算机的操作系统交互，从而表现为计算机的文件系统的格式，
				- 存储在服务器上的网络文件系统也是如此，云端的文件系统可能与本地计算机的文件系统不同，但可以通过软件将其展现为本地文件系统的样子，
		- 虚拟机
		  collapsed:: true
			- 一个模拟计算机的程序，被称为虚拟机；即计算机只以软件形式存在，它通过与主操作系统的交互来运行软件，
	- 应用程序
	  collapsed:: true
		- 浏览器
		  collapsed:: true
			- 现代的浏览器都需要处理异步事件，即在非预定时间发生、没有特定次序的事件，
			- 例如，浏览器需要响应很多不同时进行的操作，比如滚动当前页面，或者在点击“后退”按钮或另外一个链接时中断之前的请求，不管请求的页面是否已经到达，
			- 此外，浏览器还需要管理多个标签页或窗口，每个标签页和窗口都可能需要执行前述操作，
			- 因此，现在的浏览器非常类似一个操作系统，
		- 软件分层
		  collapsed:: true
			- 现代的软件都是分层组织的，这样可以相对简化复杂的软件开发问题，
			- 硬件层
			  collapsed:: true
				- 软件的最底层，
				- 硬件在很多方面几乎可以看成不变的一层，
			- 操作系统层
			  collapsed:: true
				- 硬件的上层，
				- 现代的操作系统可以向应用程序提供统一的接口或界面，而不因硬件的种种差别而变化；换言之，同一个操作系统的接口完全可以适用于不同制造商生产的不同类型的 CPU，
				- （Intel处理器的“x86”来源于 Intel 的处理器很多年都以“86”编号结尾，如80286、80386、80486 等；后来的“x64”才意味着64位），
				  id:: 62f37bae-8bc0-4a60-ac88-6c5a2e81cd0a
			- 函数层（编程语言）
			  collapsed:: true
				- 操作系统层的上层，
				- 现代的编程语言一般带有很多写好的库，提供通用的服务，这样程序员就不必重复实现这些功能，
- 通信
	- 信息系统
	  collapsed:: true
		- 通信系统都是把信息转换成物理表现形式，以便通过某种媒介传输；到了目的地，再把这些物理形式转换回人们能够理解的形式，
		- 带宽：系统传输数据的速度，
		- 延迟：衡量特定信息块通过系统所需要的时间，
		- 信程：指某种技术能够在多大地理范围内实现联网，
	- 电话线路
	  collapsed:: true
		- 调制解调器
		  collapsed:: true
			- 电话只能传送模拟的声音信号，而不是具体的声音；因此需要进行数字化信息（比特）和模拟的声音之间的转换，
			- 改变要通过声音信号传输的信息的形式叫调制，把这种形式再转换成比特叫解调；能够完成调制和解调功能的设备称为调制解调器（modem），
		- 通过电话线传输数据非常慢，而且在上网的同时不能打电话，
	- 有线电视电缆
	  collapsed:: true
		- DSL（Digital Subscriber Loop，数字用户环路）和ADSL（ asymmetric，意为“非对称”，因为下载带宽比上传带宽高）
	- 以太网
	  collapsed:: true
		- 可以在通过同轴电缆相连的计算机之间传送信号，
		- 信号则是基于强度和极性编码比特值的脉冲电压。最简单的情况就是用正电压表示比特 1，用负电压表示比特 0，
		- 每台以太网设备都有一个独有的 48 位的数字标识符，叫做（以太网）地址，
		- 以太网中的信息以包（packet）的形式传输，
		- 包是包装比特或字节信息的一种容器，格式因网络不同而异，
		- 包中的信息的格式经过了精确的定义，以便发送时打包，接收时拆包，
	- 无线网络
	  collapsed:: true
		- 无线网络通过无线电波传输数据，覆盖的范围从几十米到几百米不等，
		- 电磁波是特定频率的电波，其振动频率以 Hz 来衡量，
		- 调幅（AM）就是通过改变载波的振幅或强度来传达信息，而调频（FM）的原理则是围绕一个中心值来改变载波的频率。
		- 蓝牙
		  collapsed:: true
			- 使用与 802.11 相同的 2.4 GHz 频段。
			- 蓝牙连接的距离是 1 到 100 米，具体取决于功率大小，
			- 数据传输速度为 1～3 Mbit/s。
		- RFID（radio-frequency identification）无线射频识别
		  collapsed:: true
			- RFID 系统使用多种不同的频率，比较常见的是 13.56 MHz，
			- 被动式标签不带电源，通过天线接收到的 RFID 读取器广播的信号来驱动，
	- 蜂巢网络
	  collapsed:: true
		- 蜂窝手机是常规的电话网络的一部分，只不过连接这个网络不是靠电话线，而是靠基站发射无线电波。
		- 频段和无线电的覆盖范围都是有限的，因此就要把整个地区划分为蜂窝状的许多小区。
		- 可以将每个这样的小区想象为六边形，然后中央有一个基站，相邻的小区之间通过基站相连。打电话的时候，手机会与最近的基站通信。
		- 蜂窝电话的核心优势就是移动性，当用户移动到另一个小区时，进行中的通话就由原来的小区移交给新小区，但这个切换用户一般觉察不到。
		- “蜂窝”中小区的实际形状要取决很多因素，比如天线的辐射图形。小区覆盖面积的大小也不相同，从几百米到几十公里的都有。
		- 手机在世界的不同地区会使用不同的频带，但一般都在 900 MHz 左右。
		- 每个频带被分成多个信道，每次通话时，收发信号各占用一个信道。发送呼叫信号的信道由小区中所有手机共享，在某些系统中这个信道也可以同时用于发送短信和数据。
		- 每个手机都有唯一的识别码，相当于以太网的地址。启动手机后，它就会广播自己的识别码。
		- 距离最近的基站接收到手机信号后，会通过后台系统验证该识别码。随着手机移动，基站实时更新其位置信息，并不断向后台系统报告。如果有人呼叫该手机，后台系统就能通过一直与它保持联系的基站找到它。
		- GSM 和 CDMA 都会利用数据压缩来尽可能减少封装信号的比特量。对于通过嘈杂的无线电信道发送数据时无法避免的错误，再添加错误校验来解决问题，
	- 互联网
		- 概述
		  collapsed:: true
			- 互联网必须满足一些规则：互联网的所有接入方都要达成同样的协议和标准，如信息按什么格式组织、在计算机之间怎样交换，如何识别计算机身份并授权，以及错误发生了该如何处理。
			- 一个包就是按特定格式组织起来的一串字节。不同设备使用不同的包格式。包的内容中首先是地址信息，用于标明这个包的发送方和接收方；然后是与这个包本身有关的信息，比如包的长度；最后，通常也是最大的部分，是包输送的信息，即有效载荷。
		- 地址
		  collapsed:: true
			- 每台主机都必须有一个辨识身份的地址，才能跟互联网上的其他主机区分开来，即 IP 地址，
			- 互联网协议版本 4（IPv4）长度为 32 位（4 字节），版本 6（IPv6）长度为128 位 （16 字节），
			- IPv4 地址是互不重复的 32 位二进制数，在同一时刻任一地址只能给一台主机使用。
			- IP 地址和以太网地址类似，通常用其 4 字节的值表示，其中每个字节对应一个十进制数，数与数之间用句点分割，
			- IP 地址的分配
			  collapsed:: true
				- 先由一个中心机构把连续的 IP 地址段，如128.122.ddd.ddd分配给某个网络的管理员；
				- 此处的地址块没有数值或地理上的关系，因此没办法仅靠 IP 地址本身判断地理位置，
				- 再由管理员将 IP 地址分配给网络里的主机。这样，每台主机就有一个基于它所在网络的独一无二的地址，
		- 域名
		  collapsed:: true
			- 域名系统（Domain Name System，缩写为 DNS）用于将名字转换为IP 地址，
			- 一般称.com、.edu 等组织机构代码和.us、.ca 等两个字母的国家代码被称为顶级域名，
			- 域名只表示逻辑结构，并不受任何地理限制；一台计算机可以为多个域名服务，也可以用多台计算机为同一个域名服务，
			- 顶级域的转换工作由一组根域名服务器负责，它们知道所有顶级域（比如 mit.edu）的 IP 地址，
			- DNS 使用分而治之的策略来搜索：对顶级域的首次查询把那些在下一步查询中不可能的地址排除掉，后面的查询也是如法炮制，这样就能逐级定位到目标主机，
			- nslookup a.root-servers.net
		- 路由
		  collapsed:: true
			- 网络连接采用的设备叫网关或路由器，其实就是一种专用的计算机，用来把组成信息的数据包从一个网络发送到下一个网络，
			- 网关之间持续交换路由信息，即互联网上网络和设备的相互连接情况，并根据路由信息把收到的每个包转发到下一个离最终目的地更近一些的网关，最终传递到目标地址，
			- 互联网网关通过与邻近网关交换信息来刷新自身的路由信息，这样就能保证可能的及所需的路径信息基本跟得上网络的变化。
			- Unix 系统可以用 traceroute 程序探测路由信息，Windows 上则叫 tracert，
			- 然而，出于安全方面的考虑，越来越多的路由站点选择了关闭某些 traceroute运行必需的信息，
		- 端口
		  collapsed:: true
			- 建立 TCP 连接时，不仅要指定计算机，还要指定计算机上的端口。
			- 每个端口表示一个独立的会话。端口用两字节（即 16 位）二进制数表示，即共有 65536 个可用端口；所以，理论上每台主机可以同时承载 65536 个 TCP 会话，
			- 有一百多个众所周知的端口预留给了标准服务。
			- 比如Web 服务器使用 80 端口，邮件服务器使用 25 端口。这样，用浏览器访问 yahoo.com 网站时，浏览器会建立一个到雅虎服务器 80 端口的 TCP 连接，而邮件程序则使用 25 端口来访问雅虎邮箱，
		- 协议
		  collapsed:: true
			- 描述上述机制和其他互联网组件的协作规则与步骤，
			- 互联网的核心协议称为 IP（Internet Procotol，IP），该协议为信息传输定义了统一的传输机制和通用的格式，
			  collapsed:: true
				- 每个 IP 包都是独立的，和其他 IP 包无关，
				- 互联网协议并不能保证包传送的质量；即当包中途丢失或损坏的时候，该协议不会尝试修复，
			- 传输控制协议（Transmission Control Protocol， TCP）利用 IP 协议来提供可靠的传输机制，以便能从源地址向目标地址发送任意长度的字节序列。
			  collapsed:: true
				- 在 TCP 中，字节流切分成片段，放到 TCP 包也就是所谓的报文段里。
				- TCP 报文段不仅包含实际数据，还有控制信息构成的头部，其中包括方便接收方知晓收到的包代表
				  数据流中哪部分的顺序号。通过顺序号，就可以发现丢失的报文段并重传之。
				- TCP 报文段的头部还包括错误检测信息。这样，如果报文段出错，就很容易检测出来。每个TCP 报文段都放在一个 IP 包里传输。
				- 接收方必须对收到的每个报文段返回确认应答或否认应答；TCP 使用若干计时器来检测应答，如果计时器超时，例如某个操作耗时过长，就会启动纠错程序，
				- TCP 协议同样还包含提高传输效率的机制。比如，发送方可以在未收到上个包的信息时就继续发送下个包，接收方也可以为接收到的一组包回送一个应答。在通信顺畅的时候，这样做可以降低应答带来的开销，
		- 高层协议
		  collapsed:: true
			- TCP协议是互联网的传输机制，但没有规定所需要传输的具体信息，
			- 文件传输协议（File Transfer Protocol，FTP）
			  collapsed:: true
				- 其基本理念为，打开到一个站点的连接，从站点取回文件或者发送文件过去，然后关闭连接，
				- 可以使用ftp语句访问ftp服务器，
			- telnet
			  collapsed:: true
				- 可以用于操作远程机器，
				- Telnet 接受客户端的键盘输入并将其发送到服务器，然后 Telnet 拦住服务器的输出，并将其发回到客户端，
				- 然而，Telnet 会以明文形式发送客户端的口令，因此任何监视数据流的人都能看到口令，
				- Telnet 的继任者 SSH（Secure Shell）提供了双向加密，所以使用更为广泛，
			- 邮件传输
			  collapsed:: true
				- 简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）
				  collapsed:: true
					- 用来在不同系统之间交换邮件，
					- 先建立一条连接到收件人的邮件服务器 25 端口的 TCP/IP 连接，
					- 使用 SMTP 协议指明发件人和收件人，
					- 然后传送邮件内容，
				- 多用途互联网邮件扩展（Multipurpose Internet Mail Extensions，MIME）
				  collapsed:: true
					- SMTP 要求邮件消息是 ASCII 文本，
					- 当需要在邮件里插入照片、音乐等附件时，就要用到 MIME 机制，
				- 邮局协议（Post Office Protocol，POP）
				  collapsed:: true
					- 利用 POP 可以把邮件从服务器上取下来，在自己计算机上保存一份用来阅读，然后把服务器上的那份删掉，
				- 互联网邮件访问协议（Internet Mail Access Protocol，IMAP）
				  collapsed:: true
					- 利用IMAP可以将邮件保存到服务器上，然后从其他地方访问，
					- IMAP 确保邮件只存在一个地方，这样任何时候邮箱都是一致状态。
					- 因此，多个访问者可以同时读取和更新同一个邮箱。
			- 超文本传输协议（HyperText Transfer Protocol，HTTP）
			  collapsed:: true
				- 传递数据的基本协议，
				- GET语句
			- 点对点传输
			  collapsed:: true
				- 传统的模型为用户 - 服务器模型，即多个用户向一个（大公司）服务器请求页面，
				  id:: 62fb662f-d893-443f-a7d7-8597bb6eed3e
				- 点对点传输，指中心服务器只用于处理每个用户服务器的信息，但文件本身还是存储在用户自己的计算机上；当某个用户需要文件时，文件不经过中心系统，而是直接从一个用户的客户端传到另一个用户的客户端，
				- BitTorrent
				  collapsed:: true
					- BitTorrent协议由Bram Cohen于2001年设计，
					- 该协议规定每个用 BitTorrent 下载文件的站点，必须同时上载一部分文件；因此适用于共享较大的文件，
					- BitTorrent 用一个很小的“torrent 文件”来标记传输过程的踪迹，其中维护了谁上载和接收了哪些文件分块的记录，
				- eDonkey
				- 《数字千年版权法案》（Digital Millennium Copyright Act，DMCA）规定，包括在互联网上散发有版权的资料在内，任何规避数字媒体版权保护技术的行为都是违法的，
		- 组织
		  collapsed:: true
			- 互联网的大部分核心技术由互联网工程任务组（Internet Engineering Task Force，IETF）开发，
			- 互联网名称与数字地址分配机构（Internet Corporation for Assigned Names and Numbers，ICANN）负责互联网的技术协调，包括分配为让互联网正常运行而不能重复的名字和数字地址，如域名、IP 地址和某些协议信息，
			-
		- 错误检测和校正
		  collapsed:: true
			- 校验和（checksum）算法
			  collapsed:: true
				- 从最右一位数开始向左，*按顺序*把每个数字交替乘 1 或 2（若大于 9 就减去 9）
				- 再把各位数的计算结果加起来，
				- 若最后得到的总和能被 10 整除，那这个数字就是有效的，
				- 这个算法可以检测单个数字的输入错误，或少量数字的输入位置错误，
			- 奇偶校验码
			  collapsed:: true
				- 为二进制数字附加一个奇偶校验位，使得得到的二进制数中的数字 1 有偶数个，
					- 即原来有偶数个1的数字不改变，原来有奇数个1的数字加上一位1，
				- 如果出现一位错误，数字就会有奇数个 1，
				- 奇偶校验码实现简单，但并不能识别出哪一位有错，也不能检测两位同时出错的情况，
			- 错误检测并不是万能的，总会出现一组出错的数据恰好匹配另一种合法模式的情况，
	- 万维网
	  collapsed:: true
		- 概述
		  collapsed:: true
			- 广义的“互联网”指通过一定方式，将不同的计算机“连接”起来，即计算机之间可以相互识别，并进行数据的传输；此处的计算机可以为任何计算设备，传输的数据也可能为多种类型，
			- 万维网（World Wide Web）一般指用户的个人计算机与服务器之间的互联网，且传输的数据一般有特定形式（如HTML），
			- 万维网主要有四个组成要素：URL，HTTP，HTML和浏览器，
		- URL（Uniform Resource Locator，统一资源定位符）
		  collapsed:: true
			- 用于定位服务器，也包含了向服务器请求的信息，
			- URL的组成
				- 协议名
				  collapsed:: true
					- 即最开始的http，
					- 最常见的是http和https（表示采用经过加密的协议）
					- “file”表示信息来自本机（而不是网上）
					- “ftp”表示使用 FTP 协议传输文件
				- 域名
				  collapsed:: true
					- `://`后的字符串，
					- 域名后面可以跟着斜线（/）和任何一串字符。
					- 字符串会原样传递给服务器，由服务器决定如何处置，
				- 域名的字符编码
				  collapsed:: true
					- URL采用的字符集一般*只包含*字母，数字和少量符号；因此，大部分其它字符都需要先进行编码，
					- 一般+表示空格，
					- %表示转义符，可以将后面的*十六进制数*按照字符集标准转换为对应字符，
					- 示例：`%3A`中，3A对应十进制数58，58在ASCII中则对应`：`，因此URL中的`%3A`表示的为`：`，
		- HTML（HyperText Markup Language，超文本标记语言）
		  collapsed:: true
			- 用于描述服务器返回的信息的格式（和表现形式），
			- 标签
				- 用尖括号<>括起来的字符串，如`<title>, <img>`等，
				- HTML用标签表示格式信息，
				- 标签也可以标示页面区域的起始和结束位置，
				- 有些标签是自包含的，比如<img>；
				- 有些标签需要有结尾，比如<body>和</body>；
			- 表单
				- `<form>…</form>`标签用于通过CGI机制向服务器传递信息，
		- HTTP（HyperText Transfer Protocol，超文本传输协议）
		  collapsed:: true
			- 用于规定双向传输信息的方法，
			- 通用网关接口（Common Gateway Interface，CGI）
			  collapsed:: true
				- 用于从客户端（浏览器）向服务器传递信息，例如用户名和密码、查询条件、单选按钮和下拉菜单选项等，
			- cookie
			  collapsed:: true
				- 按照HTTP协议，HTTP 服务器向客户端返回了请求的页面后，就可以丢弃有关这次数据交换的全部记录，
				- 然而，有时服务器需要记住用户已经输入的名字和密码等信息，从而后续的每一次交互不必让用户反复输入，
				- 向浏览器发送页面时，服务器会附加若干个浏览器可存储的文本块，每个文本块就是一个 cookie；
				- 再次访问同一个服务器时，浏览器会把 cookie 发送回服务器，使得服务器可以“记住”浏览器的信息，
				  cookie 不是程序，也不包含动态内容，只是一串存储在浏览器中供以后返回服务器的字符串，
		- Javascript
		  collapsed:: true
			- 动态信息
			  collapsed:: true
				- 最初的浏览器可以帮助用户发送的信息，并能在辅助程序的帮助下显示图片、声音等信息，
				- 随着应用的发展，后续的浏览器被设计为可以运行“动态内容”，
				- 基本思路是把用某种语言写的代码下载到客户端，再由客户的计算机来运行，
			- 实现方式
			  collapsed:: true
				- Java 和 JavaScript的实现都使用了虚拟机，但两者的技术差别很明显，
				- Java 源代码在其创建之处编译，再将生成的目标代码发送到浏览器运行，
				- JavaScript 则是直接将源代码发送到浏览器，在浏览器中编译并运行；即JavaScript源代码是公开的，
		- 其他插件
		  collapsed:: true
			- 插件是第三方开发的编译好的代码，通过调用浏览器提供的 API，作为浏览器的一部分运行，
			- 一般按照使用时的需求动态加载到浏览器，
			- 常见的插件包括ActiveX，Quicktime，Flash和Silverlight等，
	- 万维网安全
	  collapsed:: true
		- 概述
		  collapsed:: true
			- 可以把万维网遇到的安全威胁大致分成三类：
			- 对客户端（浏览器用户）的攻击，
			- 对服务器（例如网上商店或者银行帐户）的攻击，
			- 对传输中信息的攻击（比如窃听无线网络），
		- 对客户端的攻击
		  collapsed:: true
			- 垃圾邮件
			- 网络钓鱼
			- 间谍软件（spyware）
				- 指运行在你的计算机上、会把你的信息送到别处去的程序。有些间谍软件是恶意的，但有些只是为了商业目的而私自收集用户信息，
		- 对服务器的攻击
		  collapsed:: true
			- SQL 注入（SQL injection）
			  collapsed:: true
				- 服务器一般在后台运行数据库，访问数据库时通常使用标准接口 SQL。
				- 如果没有严格限定访问权限，攻击者就可以提交精心构造的 SQL 查询指令来检查数据库结构，从而提取未授权的信息，甚至有可能在服务器上运行他们自己写的代码，
			- 拒绝服务攻击（DoS，Denial of Service）
			  collapsed:: true
				- 发起者把大量网络流量引导到一个网站，利用密集的访问使其停止响应。
				- 入侵者往往会在个人计算机上安装僵尸（zombie）程序，这类程序平时潜伏着，一旦控制者从互联网发来指令，就会发作并执行诸如发送垃圾邮件等攻击。这些程序一般也叫肉鸡（bot），
				- 拒绝服务攻击通常用僵尸网络来完成，
				- 从多个来源同时发起的拒绝服务攻击通常称为分布式拒绝服务攻击（DDoS，Distributed Denial of Service），
		- 对传输中信息的攻击
		  collapsed:: true
			- “中间人攻击”
				- 即攻击者截获消息，并按自身需要加以修改后发出去，该消息看起来是直接来自源头的，
			- VPN（Virtual Private Network，虚拟专用网）
				- 在两台计算机间建立起加密的通道，以保证其间双向通信的安全，
		- 密码学
			- 密钥
			  collapsed:: true
				- 用来加密消息的密文被称为密钥，
				- 现代密码学假定攻击者知道并完全理解密码系统的工作原理，并将所有的安全性都寄托在密钥上，
			- 密钥加密
			  collapsed:: true
				- 在密钥加密系统中，使用同一个密钥对消息进行加密和解密，这个密钥由参与消息交换的各方共享。
				- Rijndael 算法与 AES 标准，
				- AES 支持 128、192 和 256 位三种密钥长度，可能的密钥数量非常多，用蛮力攻击算很多年也不会有结果，
				- AES 和其他密钥加密系统面临的一个大问题是密钥分发：参与秘密通信的每一方必须知道所用的密钥，所以必须有绝对安全的渠道把密钥送到通信参与方，
			- 公钥加密
			  id:: 6305ecb1-9f40-4aaf-842d-1dbc05a5c7d8
			  collapsed:: true
				- 每个人都有一个*密钥对*，包含一个公钥和一个私钥。这对密钥是在数学上有关联的整数，
				- 为了向购物网站传输信用卡号，用户的浏览器先用网站公开的公钥加密信息，再把加密后的结果传给网站；而这个加密信息只能用网站的私钥才能解密，
				- 可见，如果私钥泄露了，则加密也就被破解了，
				- RSA算法是最常用的公钥加密算法，工作原理是生成一个
				  很大的整数（默认为512位），这个整数要有两个素因子（长度约为二者乘积的一半），以此作为生成公钥和私钥的基础。
				- 知道这两个素因子的人（即私钥的主人）能迅速解开密文，其他人要解密就得先分解素因子。然而，分解素因子的计算量非常大，几乎不可能完成的，
			- 密码学散列
			  collapsed:: true
				- 公钥算法很慢，一般不直接用公钥算法对文档签名，而是从原文档中提取一个小的文档，并保证无法从其他文档生成同样的小文档，然后再对小文档签名，
				- 签名的创建方法是用某种算法把任意长度的数据变换成固定长度的字符串，生成的字符串散列具有如下特性：无法*通过计算找到*别的输入来生成同样的散列，且输入中单个字符的变化都会导致散列中大约一半的比特发生变化，
				  collapsed:: true
					- 由于散列的长度有限，因此根据抽屉原理（鸽巢原理），理论上总会有不同的数据对应同样的散列，
				- 这样，通过比较接收者计算生成的文档摘要与原始摘要是否匹配，就能有效检测文档是否遭到了篡改。
				- 目前广泛使用的消息摘要算法有两个，即MD5（生成
				  128 位的摘要）和 SHA-1（生成 160位的摘要），
- 隐私
  collapsed:: true
	- 网络搜索
	  collapsed:: true
		- 由于查询次数的量级和互联网的量级都很庞大，因此用户在查询时，不可能直接搜索整个互联网；一般搜索引擎都是利用爬虫程序采集互联网上的所有页面，把它们的内容保存到数据库中，以便后续查询可以迅速返回结果。
		- 很多互联网页面更新得非常快，因此爬虫的采集工作一刻也不能停；然而不能过于频繁地爬一个站点，否则会显著增加站点负载，因此算法必须准确判断页面变化的频率，从而保证对变化快的站点提高采集频率，
		- 采集完页面之后就要构建索引，索引就是为网页中出现的词或其他可索引项创建一组页面和位置，并以相应的方式保存起来，以便通过任何具体的关键词都能够迅速地找到它们，
		- 最后一步就是针对具体的查询组合响应页面，谷歌的 PageRank 算法会给每个页面赋予一个权重，权重大小取决于是否有其他页面引用该页面，以及引用该页面的其他页面自身的权重。从理论上讲，权重越大的页面与查询的相关度就越高，也就会在响应界面中排在更靠前的位置，
	- 跟踪
	  collapsed:: true
		- 网页可能包含一些特定的图片，这些图片不需要点击，而是会随着页面加载而自动下载。
		- 网页中引用的图片可以来自任何服务器。于是，浏览器在取得图片时，提供该图片的服务器（根据请求中的来源页信息）就知道我访问过哪个页面了。
		- 广告公司会在很多网站协商，在网站中加入这些特定的小图片，从而通过这些图片“跟踪”用户的互联网访问“足迹”，
		- cookie和JavaScript也可以用于跟踪用户，
		- （深度包检测）
	-
-
-
-
-
- [[DataScience]]