- 准备步骤
	- 环境部署
		- 可以直接下载python.exe安装，
		- anaconda的使用
		  collapsed:: true
			- anaconda类似一个环境，而非python解释器或编辑器，
			- anaconda prompt
			  collapsed:: true
				- 官方指南https://conda.io/projects/conda/en/latest/index.html，
			- 更换镜像
			  collapsed:: true
				- anaconda navigator → environments → channels，更换至https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/，
			- 更换根目录`cd C:\Users` ，
			- 添加环境变量
			  collapsed:: true
				- 设置中搜索“环境”，进入“编辑系统的环境变量”，
				- 在path中加入python解释器的位置，然后重启powershell，就可以在powershell里直接使用python，
	- 编辑器
		- IDLE（python自带的编辑器）
		- powershell（windows自带的命令行，可以输入python后进入python环境；输入exit()可以返回powershell）
		- VS code（微软的ide，可以编辑并运行代码）
		- jupyter notebook
		  collapsed:: true
			- 在anaconda prompt中输入'jupyter lab'可以打开jupyter notebook,
			- 打开后，可以使用'http://localhost:8888/lab ' 打开新的一页，
- python程序的基本组成
	- python为解释型语言，因此可以在解释器中直接输入代码进行运算，
	- 一般的python程序包括变量和函数，
- 编程风格
	- 语句的区分
	  collapsed:: true
		- 不同于Java、c，python不用大括号和分号来标识每个语句，而是利用缩进来标识，
		- 除了应有缩进的语句没有缩进会报错，不需要缩进的语句如果额外缩进也会报错，
		- python也支持用分号区分多个语句，但不常用，
		- 一般语句只能写在一整行（即换行符会导致报错），
			- 可以利用反斜杠\ 来拆分语句，
	- 注释
	  collapsed:: true
		- \# 符号和三引号标识出来的语句会被python当作注释，不会被执行，
		- 合理的注释可让程序更容易被理解，
	- 命名风格
	  collapsed:: true
		- python区分大小写，可以包含字母、数字和下划线，
			- 变量名称不能为纯数字，也不能包含其他字符（如*、&等），关键字也不能被用作变量名，
		- 模块名一般不包含下划线，函数名和变量名一般用下划线来增加可读性，
		- 模块、函数、变量一般全小写，只有类的单词的首字母一般用大写，
		- 需要的部分常量（如PI、E等）一般字母全大写，
		- 在类中，一般使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类，
- 数据类型
	- 基本特性
	  collapsed:: true
		- 数据类型与对象相关联
			- python的数据类型与对象相关联，即变量可以为任何数据结构，
			- 优点在于，变量无需声明即可使用，
			- 缺点在于，同一变量在代码的不同部分可能会变为不同的数据结构，从而导致错误，
		- type函数可以判断值的类型，del函数可以删除变量，
		- python的命名空间
			- Python的命名空间分为三类，局部（如函数中定义的变量）、全局（如直接在交互模式中定义的变量）和内置（即python内部的关键词），
			- 在运行中遇到特定字符时，Python的查找顺序为局部命名空间→全局命名空间→内置命名空间，若仍未发现特定字符，python就会引发NameError，
			- 由于python会首先查找全局命名空间，因此应避免将部分关键词用作变量，
				- python没有将所有的内置函数都设置为不能用于命名的关键词，即使用print,tuple,max等函数名称来命名变量是合法的，
				- 然而，这样的命名规则会导致对应的内置函数无法使用，
				- 在交互模式下，使用del函数删除对应的变量就可以重新使用对应函数；但仍应避免这样的命名方式，可以在关键词后加入数字和下划线以进行区分，
	- 基本数据结构
	  collapsed:: true
		- 数值
			- 基本类型：整数、浮点数、复数
			  collapsed:: true
				- 整数的位数理论上没有限制（只受限于计算机的内存），浮点数只能有16位小数（多余的位数可以输入，但在赋值时会被舍去），
				- 由于对象和数据结构相关，因此python中可以由整数算得浮点数，但浮点数间的运算只会产生浮点数，
				- 复数
					- 由实部和虚部组成，虚部带有符号j；应注意j为未定义变量，而1j才是复数单位i，
					- 复数间的运算只会产生复数，如1j *1j会得到-1 + 0j，而不是整数-1，
					- 可以用x.real 获得实部，x.imag获得虚部，
			- 基本操作
			  collapsed:: true
				- 可以使用int, float, str函数转换数据类型，但前提为数据可以转换，如字符串'2'可以转换为整数2，
				- int函数可以接受第二个可选参数， 用来指定转换输入的字符串时采用的数值进制，
		- 布尔值
		  collapsed:: true
			- 只有True和False两种结果，
			- True类似数值1，False类似数值0，即可以对布尔值进行数值运算，
			- 反之，0可以被用作条件False，其它数值则可以被用作条件True，
		- 字符串
		  collapsed:: true
			- 组成
				- 由单引号、双引号或三引号标记的一段字符，引号中的所有字符（包括空格、字母、数字等）会被看作一个整体，
				- 默认使用双引号表示字符串，但单引号、双引号或三引号都可以被识别，
				- 由于python用缩进来标识语句的终止，因此单引号和双引号标记的字符串不能换行，但三引号标记的字符串可以换行，
					- 也可以利用反斜杠\ 来拆分语句，
				- 由空白字符分隔的字符串会被Python解释器自动拼接成整个字符串，
			- 转义字符
				- \ 符号可以将后边的字符变为其他含义，
				- 应注意，字符串仍由转义字符组成，只有使用print函数打印出字符串时转义字符才会变为对应含义，
					- print函数默认会在字符串末尾添加换行符，若字符串已经以换行符\ n结尾则会导致两次换行，可以将print函数的end参数设为""来使print函数不再添加换行符，
				- ASCII字符
					- \t代表缩进，\n代表换行；\ "，\ \则分别代表"（不会被当作字符串的结束符）和\本身，
				- Unicode字符
					- \ 也可以将后面的字符转为八进制、十六进制的数字，
			- 基本操作
				- 下标
					- 索引
						- [n]表示字符串中的第n个字符（n∈N+），
						- 索引从0开始而并非从1，即[0]表示第一个字母，
						- 索引也可以为反方向，即负数索引[-1]，代表最后一个字符，
					- 切片
						- [x:y]返回从第x个字符到第y个字符的字符串片段（不包括第y个），
						- 切片也可以为负方向，
						- x/y可以省略，省略时表示从头部/尾部开始；两个都省略时则会复制原字符串，
				- 数学符号
					- +可以连接两个字符串，* 可以按指定次数重复某个字符串，但不常用，
				- 布尔运算
					- in运算符可以判断元素是否在字符串中，
			- 函数与方法
				- 函数
					- len函数可以返回字符串中字符的数量，
					- print函数可以将输入的对象转换为字符串后显示出来，但不会输出结果，
						- print函数可以接收多个参数和关键字参数，如print("a", "b", "c", sep="|", end="\t")会输出a|b|c ，
					- repr函数和str函数可以将任意对象转换为字符串，但形成的具体的字符串会有差异，
					- list函数可以将字符串转换为列表，并应用列表方法修改，
						- 修改完后可以使用join方法将列表转换回字符串，相比之下，str函数会将整个列表当作一个字符串，
				- 方法
					- 分割与组合
						- split方法以所有空白符号（空格、\ t和\ n等）为界，将字符串分割为子字符串，返回一个子字符串组成的列表
							- split方法可以接受可选参数arg1作为分界符，
							- split方法可以接受可选参数arg2作为分解次数，
						- join方法以字符串列表为参数， 将字符串连在一起形成一个新字符串，
							- join方法接受的字符串列表为参数join(list1)，并非对象x.join；但join方法仍需要字符串对象，不能直接使用方法，
							- 调用join方法的字符串对象会被作为分隔符插入新的字符串中，
					- 修改
						- 应注意，已经定义的字符串无法被重新赋值；但可以利用旧的字符串创建一个新的字符串，
						- strip方法默认移除原字符串首尾的空白字符，并返回新字符串，
							- lstrip和rstrip方法的功能类似， 只不过分别移除的是原字符串左边或右边的空白符，
							- strip方法可以接受可选参数arg1作为需要移除的字符，所有即在字符串中又在arg1中的字符都会被移除，不受arg1的顺序影响，
						- replace(arg1, arg2)将字符串中的arg1全部替换为arg2，
							- 若需要修改多个对象，可以综合利用maketrans和translate方法，
						- "...{0}...{1}...".format(arg1, arg2...)会按照顺序将字符串中由{n}表示的对象按数字顺序逐个替换为arg1，arg2，
							- 可使用关键字参数，指定原字符串中需要更改的子字符串，
							- 可使用格式描述符进行更精确的转换，
						- upper、lower()将字符串的字母全部转换为大写、小写，
					- 查找
						- find方法需要参数arg1，返回第一个arg1在字符串对象中的位置，如果未找到则返回-1，
							- rfind方法类似find方法，但是从字符串的末尾开始搜索， 返回的也是arg1在字符串中最后一次出现时的位置，
							- index、rindex方法类似find、rfind方法，但在字符串中找不到arg1时不会返回-1， 而是会引发ValueError，
						- startswith和endswith方法检查字符串的开头或结尾是否为arg1，并返回True或False二者之一，
						- count方法查找字符串中是否有arg1，并返回arg1的数量，不存在arg1则会返回0，
			- bytes对象
				- 处理二进制数据（如从二进制数据文件中读取数据等）会用到bytes对象；bytes对象在处理国际字符集时也会有应用，
				- encode方法可以将字符串转换为bytes对象，bytes对象的decode方法可以将其转换为字符串，
	- 高级数据结构
	  collapsed:: true
		- 列表
		  collapsed:: true
			- 组成
				- 有顺序的多个值组成的序列，由方括号[]括起来，元素间用逗号连接，
				- 值可以是各种数据类型（数值、字符串、列表、字典等），但列表中嵌套的一整个列表会被视为一个元素，
				- 列表中的数值是可变的，长度也是可变的，因此不需要事先声明，
				- 可以将列表的值赋给变量，
				- 只含有单一元素的列表仍然是列表'[item]'，而不是字符串'item'，
			- 基本操作
				- 下标
					- 索引、切片方法与字符串相同，
					- 下标可以嵌套使用，如(list[1])[1]或list[1][1]，但应注意对象是否为仍为列表，
					- 列表是可变的，因此可以通过下标方法修改特定的元素，list[n] = arg1可以将列表中的第n个元素替换为arg1，
						- 下标修改操作不能更改列表的长度，即不能通过下标修改超过原列表长度的值，
				- 运算符号
					- 加号可以将两个列表连在一起（并非将每个对应值相加），乘号可以形成新的重复几次的列表（并非将列表中的每个值相乘），
					- 运算符号不会改变原列表，而是会返回新的列表，
					- 列表不能进行减法、除法运算，
				- 布尔运算
					- in运算符可以判断元素是否在列表中，但只能初步识别，
						- 可以利用下标进一步识别嵌套列表中的元素，
			- 函数与方法
				- 注意事项
					- 应注意函数可能改变、不改变原列表，返回新列表或None，
					- 由于部分函数可能会直接修改原列表，为了保险起见，可以创造关于原列表的副本，
				- 函数
					- len函数返回列表的元素数量，
					- max、min函数返回列表中的最大、最小值，
					- sum函数可以对数值型列表进行求和，
					- sorted函数可以将任意可迭代对象（字符串、元组、字典等）排序，并返回一个列表，
					- del函数可以删除n索引位置的元素，
						- del函数可以不加括号使用，即del list1[n]的形式，但不能作为方法使用，
				- 方法
					- 应注意，大部分方法都会修改原列表，不产生返回值（即返回None），
					- 元素修改
						- append(arg1)，将arg1作为一个整体添加到列表末端，即输入的列表也会被当作一整个元素，
						- extend(list1)，将列表（仅接受列表）中的元素添加到列表末端；
						- insert(n, arg1)，将元素arg1插入到列表的n索引位置前，
						- remove(arg1)，搜索列表，并删除列表中的arg1元素；列表中不存在arg1则会引发错误，
					- 排序
						- sort方法可以对列表进行排序，
							- sort方法也可以对嵌套列表进行排序，python规定的排序规则为先升序比较第一个元素， 再升序比较第二个元素，以此类推，
							- 可以利用关键字参数key来自定义排序规则，
							- sort只能对列表进行排序，字符串、元组、字典没有sort方法，
						- reverse方法可以将列表按逆序重新排列，也可使用sort方法的附带参数reverse = True来实现，
					- 其它
						- index(arg1)，查找列表中是否有arg1，并返回arg1的位置；列表中不存在arg1则会引发错误，
						- count(arg1)，查找列表中是否有arg1，并返回arg1的数量；列表中不存在arg1则会引发错误，
				- 嵌套列表复制
					- 若列表1 = [元素1]，列表2 = [[列表1], 元素2]，
						- 修改列表1中的元素1，会导致列表2中的列表1的同步变化，
						- 直接修改列表1（改为另一个列表、字符串等），列表2不会变化，
					- 浅复制
						- 操作x[:], x+[], x*1 可以得到列表的浅副本，修改浅副本中的嵌套列表的值会导致原列表的同步变化，其他元素的修改则不会产生影响，
					- 深复制
						- copy模块的deepcopy函数可以得到列表的深副本，修改深副本中的嵌套列表的值对原列表没有影响，
				- 循环
					- 列表可以使用for循环遍历，
			- 其它操作
				- 大部分常用列表操作可以归为映射、筛选和归并三类，（一般需要通过遍历列表中的元素来实现）
					- 映射：将给定列表中的每个元素用函数转化为另一个元素，并生成新的列表，
					- 筛选：根据给定特征选出给定列表中的部分元素，并生成新的列表，
					- 归并：将列表中的元素根据给定规则整合为单一的输出值，
		- 元组
		  collapsed:: true
			- 组成
				- 有顺序的多个值组成的序列，由括号()括起来，元素间用逗号连接，
				- 一般用括号()将元组括起来，但并非必须，直接用逗号隔开各个取值的输入也会被python识别为元组；
					- 同理，应将多个用逗号隔开的值看成一个元组，而非离散的各个元素，
				- 不同于列表，元组中的值是不可变的，因此可用作字典的键，
					- 然而，元组中的元素可以为可变对象（列表等），类似于嵌套列表，
					- 包含了可变对象的元组不能用作字典的键，
			- 基本操作
				- 下标
					- 索引、切片等操作类似列表，
					- 元组中的元素的不可更改，即不可以重新赋值；但可以利用类似更新字符串的方式，利用已有元组构造新的元组，
				- 运算符号
				- 布尔运算
				- 元组赋值
					- 元组可以出现在赋值操作符的左侧，即可以将右侧元组中的数值依次赋予赋值操作符左侧元组中的元素，
					- 在变量前加上* 可以让变量接受多个元素，变量的默认形式为列表，
			- 函数与方法
				- 由于元组不可更改，所以许多列表方法都无法使用，但函数的使用类似列表，
				- 函数
					- 可以用list(), tuple()函数在列表和元组间转换对象，
					- zip函数
						- 接受多个序列组，返回一个元组列表，每个元组包含了各个序列中相对位置的一个元素；
						- zip函数并不产生输出，可以通过列表list将其输出赋值给一个列表，
						- 如果输入的序列的长度不一，则返回的对象以最短序列的长度为准，
		- 字典
		  collapsed:: true
			- 组成
				- 多组“键值对”组成的序列，由大括号{}括起来，元素间用逗号连接，每组元素间用：对应——冒号左侧的值称为“键”，右侧的值称为“值”，
				- 多个键可以对应同一个值，但是必须要分开为多个键分别储存，而不能储存为一个键；相比之下，一个值只能对应一个键——若输入了多个键，则python默认只保留其中最大的一个，
				- 每组元素必须为一一对应，但元素可以为数值、字符串、列表、元组、字典，
				- 字典的值的数据结构没有限制，但键必须是“可哈希的”，
					- 哈希函数接受一个值（任意类型）并返回一个整数，字典使用这些整数存储和查找键值对，
					- 键必须为不可变的，否则同一个键可能会对应多个哈希值，从而阻碍字典的工作，
					- 列表可以作为字典中的值，但是不能作为键，因为列表是可变的；同理，字典本身也不能作为键，
			- 基本操作
				- 赋值
					- 可以通过dict[arg1] = arg2的方式对字典赋值——当arg1为整数时，此方法类似列表的下标操作，但实际上字典并非按下标顺序构造元素，仍是只存储了键值对n:arg2，
				- 下标
					- 不同于列表和元组，字典利用关键字来查找对应值，所以其中的项的顺序没有列表那么重要，
					- 仍可以使用下标访问字典中的值，但只有正整数索引，且只能访问字典中的值，不能访问键，
					- 字典不能进行切片操作，
				- 查找
					- 可以使用类似下标的操作寻找字典中给定的键对应的值，
					- 一般而言，字典不能直接进行逆向查找，即较难以通过值寻找到对应的键；一般可以通过for循环遍历字典来寻找，且应注意一个值可能对应多个键，
				- 运算符号
				- 布尔运算
					- in函数可以检查字典中是否存在某个键（不能检查值），
			- 函数与方法
				- 函数
					- len函数可以返回键值对的个数，
					- sorted函数可以重排字典，但输出的为键的列表而不再为字典，
					- del函数可以删除键值对key1:values1，
						- del函数可以不加括号使用，即del dict1[key1]的形式，但不能作为方法使用，
				- 方法
					- keys方法可以返回字典中的键的集合，values方法可以返回字典中的值的集合；items方法返回一个多个元组组成的序列，其中的每个元组为字典的一个键值对，
						- 三者返回的分别为dict_keys、dict_values、dict_items对象；修改字典时，dict_keys、dict_values、dict_items对象会同步变化，
						- dict_keys、dict_values、dict_items对象可以用for循环遍历，也可以用in操作符来判断键、值是否在字典中，但可执行的操作不同于列表，而更类似于集合，
						- 可以使用list函数将其转换为列表，转换后的列表不会再与字典同步变化，
					- get(arg1, arg2)在字典中存在键arg1时返回values1，不存在键arg1时则返回arg2（不指定arg2时则会返回None），
					- ，dict1.update(dict2)会用dict2的所有键/值对更新dict1，如果键在两个字典中都存在， 则第二个字典中的值会覆盖第一个字典的值，
					- zip方法
						- 可以利用dict和zip方法将两个元组组合在一起，创建一个简单的字典，
				- 复制
					- 浅复制
						- copy函数可以得到字典的浅副本，若字典中有嵌套列表，则修改浅副本中的嵌套列表的值会导致原字典的同步变化，其他元素的修改则不会产生影响，
					- 深复制
						- copy模块的deepcopy函数可以得到字典的深副本，
			- 字典应用
				- 判断出现频率
					- 利用字典的键值对应和值的可更新性，可以综合利用for循环和字典，来判断某一对象的出现频率；
				- 稀疏矩阵
					- 一般的m*n矩阵可以利用嵌套列表来表示为向量的形式，即[[m11, m12...], [m21, m22...]...]，但对于较庞大的，且多个元素为0的矩阵，这种表示方式会较为冗余，
					- 可以利用字典和元组索引只存储不为0的元素及其位置，如{(mi, ni) : ki, (mj, nj) : kj...}的形式，可以减少冗余度，
				- 字典缓存
					- 函数默认不会记录已计算的参数；因此，迭代函数可能会进行很多次重复的从头开始的计算，
					- 可以通过让函数记录已经计算的值，并利用字典保存，综合if-else语句，在函数需要计算值时先从字典中查找值是否已经算得，从而直接取值并简化运算，
		- 集合
		  collapsed:: true
			- 组成
				- 无序的多个值组成的序列，由大括号{}括起来，元素间用逗号连接，
				- set函数接受一个列表、元组、字典等序列变量，返回一个集合
					- 列表、元组中的重复变量只会被计数一次——但set函数不会计算嵌套列表中的变量，即嵌套列表会被算作一整个元素，
					- 对于字典，set函数只会将字典的键组合为集合，
				- 集合中的项必须是不可变的、可哈希的，但集合本身是可变的，
			- 基本操作
				- 数学操作
					- 类似数学中的集合，“|”可获得两个集合的并集， “&”可获得交集，“^”则可以求得属于其中一个但不同时属于两个集合的元素，
				- 布尔运算
					- in运算符可以判断元素是否在集合中，
			- 函数与方法
				- 函数：类似列表，可以使用len、min、max等函数，
				- 方法：虽然集合可变，但具体方法并不完全等同于列表；
					- 集合需要使用add方法来附加元素，而不是append，
					- 集合同样使用remove方法来删除元素，
			- 不可变集合
				- 同set函数类似，forzenset函数同样可以接受一个列表、元组、字典等序列变量，返回一个集合；但返回的集合不可变，
	- 其它
	  collapsed:: true
		- None值
			- 部分计算过程不会显式地输出结果，但运算过程的确发生了，这些过程默认的返回值为None，
- 基本操作
	- 赋值
	  collapsed:: true
		- 在python中，=为对新的自变量赋值，而==则更类似传统数学意义上的相等，
		- 重复赋值
			- 对同一变量进行多次赋值是合法的，python中的等号而并非数学意义上的等同关系，
			- 例如x = x + 1的含义为：获得 x 的当前值，与 1 做加法求和，将 x 的值更新为所求的和，结束，
	- 代数运算
	  collapsed:: true
		- 运算顺序
			- 代码执行顺序为从左到右，从上到下；每一步操作都会为下一步操作的调用产生一个临时对象，
			- 等号并非纯数学意义上的等同，而是赋值的含义，
		- 算术运算
			- 在python中，`*`代表乘法，`**`代表乘方，而^代表XOR（异或），
			- 运算顺序：括号、指数、乘法/除法、加法/减法，
			- 字符串一般不能执行运算，但可被理解的加法、乘法运算（如连接两个字符串）是合法的，
		- 其他算数运算
			- 地板除法//，丢弃小数返回整数，
			- 求余运算符%，只返回余数（不返回除尽的整数），便于查看能否整除，
		- math包提供了额外的数学运算；
		- cmath包可以对复数进行运算，但返回的结果也为复数，
	- 布尔运算
	  collapsed:: true
		- 仅返回True或False两个结果之一，
		- 基本关系运算符
			- ==，用于比较两个值是否相等，
			- !=（不等于），>=（大于等于），<=（小于等于）
		- 逻辑运算符
			- and，or，not；其含义与英语中的意思类似，
		- any、all函数
			- any接受一个布尔值序列（列表、元组等）作为参数，当其中任意一个值为True时返回True，
				- 并非需要直接输入布尔值，也可以输入会输出布尔值的特定语句，
				- 例如，any函数可以与生成器表达式一起使用，可以简化for循环的流程，
			- all函数同样接受一个布尔值序列（列表、元组等）作为参数，但是只有所有的值都为True时才会返回True，
		- 其它
			- in运算符，接受字符串，若第一个字符串作为子串出现在第二个中，则返回 True，
			- is运算符，接受字符串、列表；若两个字符串、列表“相等”，则返回True，
				- 两个相同的字符串在python中为同一对象，即is和==都会返回True；但两个“相同”的列表在python中则不是同一对象，虽然==会返回True，但is会返回False
				- 这里的相同被理解为两个列表的每个对应元素相同， 但仍然分属于两个不同的列表。
				- 列表是可变的，除非赋值a=b，这样a、b会同步改变，否则对a的改变不会影响b；相比之下，字符串是不变的，
- 复合语句
	- 编程语句分类
	  collapsed:: true
		- 顺序语句（逐个执行每条语句）
		- 选择语句（根据所给条件判断执行的具体语句）
		- 循环语句（将某条语句重复执行多次）
	- 复合语句
	  collapsed:: true
		- python中的复合语句通过冒号和缩进来标识，而不是括号和分号，
	- 复合条件
	  collapsed:: true
		- if和while语句只能接受一个“条件”，但条件可以为多个布尔表达式的复合，
		- 对于复杂的任务，可以利用逻辑运算符等方式在一个语句中嵌套多个条件，
		- 应注意嵌套条件可能难以理解，最好附加一定的注释，
	- if-elif-else语句（选择语句）
	  collapsed:: true
		- if condition：
			- elif condition：
			- else：
		- 组成
			- 中间的条件可以用elif指示，elif语句的数目没有限制，也可以没有elif语句（即if的条件为False时不执行操作）；可以没有else语句，但else语句（如果有）必须在末尾，
			- 除了条件，if语句需要有可被执行的主体部分，否则会报错；
			- 可以利用pass语句作为主体，无论条件真假都不会执行操作，
			- 解释器会逐个检测条件，检测到语句为真后就会执行语句，然后结束任务，不会再检查剩余的语句，
		- continue语句
			- 可以跳过循环内接下来的语句，重新返回while语句的条件判定，
	- while语句（循环语句）
	  collapsed:: true
		- while condition :
			- 假→退出while语句，执行接下来的语句；
				- 理论上while语句也需要else语句作为替代选择，但一般不需要写出else语句，直接写出的替代语句也是合法的，
			- 真→执行while语句，完成循环后返回，再次判断真假，
			- 除了条件，while语句需要有可被执行的主体部分，否则会报错；
			- 可以利用pass语句作为主体，无论条件真假都不会执行操作，
		- continue语句
			- 可以跳过循环内接下来的语句，重新返回while语句的条件判定，
	- for语句（循环语句）
	  collapsed:: true
		- 组成
			- for item in sequence：
				- func（item）
			- 遍历任何可以迭代（iterable）的对象，对序列中的对象逐个执行对应语句，
				- 例如， 对象可以为列表、字典（键）、元组，也可以为字符串；但不能为整数或浮点数，
				- for语句只会遍历给定的序列，并对给定序列中的对象执行语句，因此有时需要与if语句等组合使用，
			- for循环的基本顺序为数列1，2，3...，即序列中的第一、第二、第三个元素，以此类推，
		- 元组对象
			- for循环的对象可以为元组（多个对象），但前提是给定的序列中的对象可以拆分为对应的几组，
			- for循环不能识别嵌套列表，即对嵌套列表进行遍历时，嵌套列表中的元素会被视为一个对象，
		- range函数
			- range(a, b, c)返回按照c为差值，由a到b-1的range对象，默认a=0，c=1，即range(n)返回range(0, n)，
			- range(0, n)类似于正整数列表[0, 1..., n-1]，但所占用的资源更少，且可以作为for循环需要遍历的序列，
		- enumerate函数
			- 接受一个列表作为参数，返回一个类似字典的enumerate对象；其中“字典的值”为0，1...正整数索引，“字典的键”为列表中的逐个对象，
			- enumerate对象可以作为for循环需要遍历的序列，
		- zip函数
			- 可以从一个或多个可迭代对象中逐一读取对应元素， 并合并为zip对象，
			- 若对象的长度不等，则最终生成的zip对象的长度为最短对象的长度，
			- range、enumerate、zip函数生成的对象都可以用list函数转换为列表，但其对象本身就可以用于for循环，因此转换并非必须，
		- 其它
			- 条件表达式：将语句写在一整行中，不换行和加入冒号；一般在条件语句（if语句）的分支表达式均比较简单时使用，可以简化代码，
			- 列表推导式：利用for语句，直接在方括号中构造新列表，不新建额外的空白列表；对于简单的表达式，可以简化代码并加快for循环的运行速度，
			- （字典推导式：类似列表推导式，将括号改为大括号即可构造新字典），
			- 生成器表达式：类似列表推导式，但使用的为圆括号，且构造的对象为生成器（generator）而不是列表，生成器可以用for循环遍历，
	- try语句（调试语句）
		- try-except-else语句
			- try语句
				- try语句没有额外的语法要求，只需要在代码语句前加入try:语句，
				- python从try子句开始顺序执行，如果一切正常，则程序会一直执行下去，并跳过except语句，
				- 需要try语句后的代码的成功执行才能执行的代码可以放在else语句后，但也可以没有else语句（即所有语句都写在try语句后），
			- except语句
				- 若出现异常，程序会跳出try子句并逐个搜索except子句，判断是否为对应的情况，然后执行对应的except语句并终止程序，
				- 一般而言，except语句的目的不是直接触发或打印异常，而是给出异常情况下的其它可选操作，即一般写法为`except Exception: print("error information")`，而不是`except：Exception`，
				- except语句需要准确的异常判定，即except Exception:中给出的异常需要与执行try语句后可能出现的异常对应，
				- 如果异常不能准确对应， 一般程序也可以继续运行，但except后的语句不会被执行，
		- Python异常机制
			- Python异常机制是按照面向对象的规范搭建的，主类为BaseException，
			- 子类为SystemExit、KeyboardInterrupt、GeneratorExit和Exception四类，其中主要的异常都被包括在Exception子类中，
			- 可以自定义新的异常类，
		- raise语句
			- 可以触发异常，并接受一个详细的错误信息作为可选的实参，
			- 如`raise IndexError("Just kidding")`会触发IndexError: Just kidding，
	- break语句
	  collapsed:: true
		- 可以立即终止循环，即循环内的语句和循环外的语句都不会再被执行，
- 函数（function）
	- 定义
	  collapsed:: true
		- 有命名的，执行某个计算的语句序列；基本结构为名称和语句序列，核心是对参数进行运算并输出结果，
		- 因此构造函数时应首先明确输入的量是什么，以及希望得到的输出是什么，然后推导中间的可能步骤；
		- 一般而言，函数解决同一问题的解法和路径可能是多样的，但是输入和输出则一般比较固定；因此，明确输入和输出可以帮助理清逻辑，
	- 函数方法
	  collapsed:: true
		- 算法中可能存在很多重复或类似的操作，而计算机擅长重复执行类似的行为，
		- 因此，应该尝试将算法中的重复操作定义为一个函数，用函数去描述这一系列操作，
		- 理论上，每次操作都写出完整的操作语句也可行，但这会导致代码变得冗长；此外，利用函数去描述操作可以辅助思考如何提升算法，从而改善程序，
		- 然而，对于复杂问题，最好首先想出一个可行（但可能较复杂）的算法，再尝试利用函数去改进，而不是直接从函数的角度去思考问题，
	- 自定义函数
	  collapsed:: true
		- 组成
			- 基本组成def func_name(arg1, arg2...):，
			- python函数利用缩进来判断语句，因此不需要特定符号（如大括号）来表示结尾，但应注意语句间的准确缩进，
		- 输入
			- 参数
				- 实参（argument）和形参（parameter）
					- 定义
						- 实参指具体的（如人为输入的）数据，而形参则是计算机存储的环境中的变量（可以是变量，也可以是函数），
						- 例如，定义函数时输入的def add(t)中的t为形参，而调用时输入的add(3)中的3为实参，
					- 运算规则
						- 函数运算时先将实参转化为形参，再调用函数根据形参运算，最后输出结果，
						- 若定义函数时没有指定形参，调用时输入形参就会导致报错，
					- 变量实参
						- 除了人为输入的数据，python环境中的变量也可以被用作实参，
						- 对于不可变对象（如元组、 字符串和数值），形参的操作不会影响函数外部的实参的取值，
						- 对于可变对象（如列表、 字典），函数内部对形参做出的改动会改变该实参的具体值，但函数内部对形参的重新赋值不会影响实参，
				- 全局（global）变量与局部（local）变量
					- 定义
						- 全局变量，属于“__main__”，可以被任何函数访问，在进行过函数运算后也不会消失，但变量的值可能会发生改变；
						- 局部变量，一般在定义函数时引入，仅在函数内部出现，函数运行结束后就会消失，无法被再次调用，
					- 变量声明
						- 可以在函数内部使用global函数global arg1，告知函数调用全局变量，
						- 对于不可变对象（如元组、 字符串和数值），声明全局变量后，函数内部形参的操作会改变实参的取值，
							- 如果只是要访问函数外的变量， 则不需要将其声明为nonlocal或global，
					- 其它
						- 参数命名
							- python默认函数内定义的变量为局部变量，因此理论上局部变量可以与已定义的全局变量重名，
							- 函数内声明了全局变量时，定义函数时命名的形参与已定义的全局变量不能重名，
						- 过多的全局变量可能会增加函数调试的难度，应注意变量的合理命名与使用，
				- 参数输入
					- 位置参数
						- Python默认按定义时形参的位置接受实参，即def func_name(arg1, arg2...):，func_name(a, b...)中的a，b...会分别赋值给arg1，arg2...，
						- 若没有设定默认值，则输入的实参与函数的形参数量不符合时会报错，
					- 默认参数
						- 可以为参数设定默认值，如def func_name(arg1, arg2= default2...):，对于设定默认值的形参，若没有外界输入的对应实参，python会按照默认值对函数进行运算，
						- 设置函数时，带有默认值的形参必须在末尾，
					- 关键字实参
						- 对于具有多个实参的函数，可以在指定实参取值时加入实参的名称，如func_name(a, arg2 = b...)，
						- 输入实参时，
							- 若输入的实参都指定了关键字，则此时可以不按照设定函数的实参顺序输入，
							- 若既有位置参数也有关键字参数，则关键字参数必须在最后，
					- 多个输入参数
						- * 符号可以汇集多个参数，使函数可以接受任意数量的参数，即def func_name(*arg):会将接收到的实参a，b...组成一个元组传递给函数，
						- ** 符号可以汇集多个关键字参数，使函数可以接受任意数量的关键字参数，即def func_name(**arg):会将输入的关键字和参数汇集到一个字典中（字典的键为多余实参的关键字（形参名称），字典的值为实参）传递给函数，
						- * 符号和** 符号必须在函数定义参数的最后，且两者不能互相代替，若输入的参数两类都有，则需要同时定义两种方法，
				- 其它注意事项
					- 形参的命名不会影响具体输入的实参，但仍应遵循基本的命名规则，
					- 变量和形参都是局限于函数内部的，如果不指定，那么函数结束时变量就会消失，
			- 用户输入
				- input函数可以暂停程序运行，并等待用户输入（但输入信息并不会触发任务执行，需要按下enter才会触发任务）,
				- input函数会将外界输入赋值给一个变量，默认的赋值为字符串，如有需要，可以使用int或float函数来转换为数值，
				- input函数附带可选的字符串参数，用于提供关于输入信息的提示，
		- 输出
			- 类型
				- 输出一般包括三种：输出数值，返回数值（但不输出），执行行为（不返回值），
				- 在交互模式下，解释器会显示函数的输出；但脚本模式下，返回数值不一定会输出，
				- 执行行为不同于返回数值——部分行为会返回“结果”，但这些结果并非具体“数值”，因此无法赋予给一个变量；将无返回值函数的结果赋给一个变量会得到特殊值None（类型None，并非字符串'None'），
				- 特定的函数内部运算也会返回None，由于None无法进一步运算，因此在设置函数时应注意避免返回None的操作，
			- 显示输出
				- print函数可以显示输出，但不产生返回值（返回None），因此print函数不能用于赋值变量，
				- return函数
					- 可以将函数计算出的数据返回为数值，且return函数后的语句不会再被执行，
					- 应尽量保证需要的语句最终以return函数结尾，否则没有以return函数结尾的语句就会输出None（一般不符合设计函数的本来目的），
					- 在程序较为复杂时，可以先使用print函数打印出结果，待确认无误后再使用return函数输出结果，
				- 产生多个输出值
					- 一般而言，函数只能返回一个值；但可以将返回值设置为元组（或列表、字典），则其效果类似于返回多个值，
		- 注释
			- 以# 标记的语句，或由三引号'''括起来的语句，
			- 一般被用在函数的开始位置，向他人说明使用函数时应该了解的关键信息；如函数的作用，不同实参的含义等，
			- 很长的程序由于形式语言的固有特性，具有的可读性较差，应该利用自然语言做一定的标记，
			- 代码所实现的行为一般较容易理解，因此注释应注重描写代码所表达的隐含意思，如变量的含义或与上下文的联系，
			- 设计良好的函数应该是容易解释的，反之，若函数的作用难以解释，则说明函数还有一定的改进空间，
	- lambda表达式
	  collapsed:: true
		- 可以看成小型函数，一般函数为def func(arg1): func(arg1)，而lambda表达式为lambda arg1: func(arg1)，即不需要def语句和具体的函数名称，
		- 若函数的语句较少，则可以利用lambda表达式在行内完成函数定义，而不需要额外定义一个函数，
		- lambda表达式会自动产生返回值，所以不需要return语句，
	- 函数赋值给变量
	  collapsed:: true
		- 可以将函数“赋值”给变量，即arg1 = function（不带括号），
		- 其作用之一为简化函数的名称，即引用函数时可以直接使用arg1(a，b...)，用法等同于使用原来的函数，
		- 可以结合字典使用，在需要调用多个函数时会有帮助，
	- （装饰器函数）
	  collapsed:: true
		- 函数可以作为实参传递给其他函数， 还可作为其他函数的返回值回传，
		- 装饰器可以将一个函数包装到另一个函数中去，
	- （生成器函数）
	  collapsed:: true
		- 函数内部定义了while或for循环时，可以用yield关键字逐个返回迭代的值，
		- 当没有可迭代值、遇到空的return语句或函数结束时，生成器函数将停止输出返回值，
- 类（class）
	- 定义
	  collapsed:: true
		- 引入
			- 类指现实世界的“一类”物体，这一“类”中的“实例”在个性上存在差异，但拥有相同的一些共性，因此可以抽象为同一类拥有不同“属性”的总体，
			- 例如2，3，4都可以进行+、-运算，都不能除以0；所以可以将其归为整数“类”；2、3、4就是具体的“实例”，
			- python中的数据结构（包括整数、字符串、列表、字典等）本质上就是不同的类，
				- 因此，指定的每一个具体的列表都拥有列表类所有的“属性”，且都可应用列表类所能使用的“方法”，
			- 根据类来创建对象被称为实例化（instantiation），手动赋值的具体变量则称为类的实例（instance），
		- 方法
			- 类中的函数被称为“方法”，“方法”一般会有一些特有的命名、参数和使用规则，但与其它python函数并没有实质上的区别，
			- 方法可以理解为现实世界中物体“交互”的方式，即物体能做出的行为，
		- 属性
			- 类中的实例所具有的“基本性质”被称为“属性”，即实例所具有的那些共性，
	- 自定义类型
	  collapsed:: true
		- class函数与说明
			- class函数class Class1():
			- 说明
				- 用于对类型进行说明的字符串，一般写在最开始的位置，并用三引号'''括起来；这样写出的注释可以使用doc方法访问，即Class1.__doc__（但上述语句不会产生返回值，应使用print函数将其打印出来），
				- 对类型进行详细的说明有助于他人的理解，也有助于后期的调试，
		- 方法与属性
			- init方法与属性
				- 定义`def __init__(self, attr1, attr2...):`，
					- 参数
						- self参数
							- 一般第一个形参命名为self，即指代具体对象本身，
						- 属性
							- init中的其余形参规定了对象的属性（attribute），即与其它方法中的形参不完全相同，
							- 指定属性与参数的对应后，就可以在其他方法中用点标记法使用实例的属性，即使用self.attr1会返回设置实例时规定的具体属性值，
						- 同自定义函数一样，也可以指定属性的默认值，但指定了默认值的属性必须在最后，
						- （可以不设置其他属性），
					- 组成
						- init函数的基本组成一般为对属性的指定，即`self.attr1 = attr1, self.attr2 = attr2...`，
						- （可以只在init函数的组成中设置属性`self.attr_n = attr_n`，而不写为init的形参；这样的属性也可以更改，只是不能在设置实例时更改），
				- 使用`object1 = class1(attr1, attr2...)`，
					- init函数对应了生成类中的具体对象的方法，且会自动返回一个对象，因此不需要再使用return语句，
					- 可以不指定属性，此时init会返回设置的默认值，但不能忽略括号（括号代表对类的使用，不加括号则代表类本身），
			- 方法
				- 定义`def func1(self, attr1, attr2...)：`，
					- 参数
						- 类中的方法的第一个形参一般也为self，即指代具体对象本身；
						- 其余参数类似于自定义函数的形参，方法中也可以不设置其余参数，
						- 同自定义函数一样，一般也可以指定形参的默认值，但指定了默认值的形参必须在最后，
					- 组成
						- 由于定义类中的方法类似自定义函数，所以把已设置的外部函数进行适当修改后移入类的定义中，即可将外部函数变为一个方法，
						- 不同于init函数，自定义方法不会默认产生返回值，设置时应注意，
				- 使用`object1.func1(attr1, attr2...)：`，
					- 可以不指定形参，此时方法会返回设置的形参的默认值，但不能忽略括号（括号代表对方法的使用，不加括号则代表方法本身），
					- 不同于外部的自定义函数，定义在类中的方法不能直接调用，只能由实例通过方法调用，
						- 换言之，定义在类外部的函数可以与类中的方法重名，但不合适的命名可能会导致误解，
			- 属性
				- 设置属性
					- 一般在init函数中设置完所有属性，
					- 可以在方法中设置init中没有的新属性，但不调用对应方法时，实例就不会有对应的属性，
					- 可以用点标记法给具体实例设置新的属性`object1.attr1 = str1`，但设置的属性仅有对应实例拥有；不可以用点标记法给类设置新的属性，
				- 修改属性
					- 可以直接通过点标记法更改属性，即`object1.attr1 = str1`，但这种方式不常用，
					- 一般通过类中的方法接受外界参数，对实例的属性进行修改，
			- “特殊方法属性”
				- 定义
					- 可以理解为在类中对python原有的“方法”进行重新定义，
					- 当对类中的实例应用一些内置方法时，python就会首先调用类中重新定义的方法，
				- 字符串方法
					- 可以在类中定义`__str__`函数，当Python请求该类的实例的可读字符串形式时，类就会调用`__str__`方法，并将其返回值用作请求的字符串，
					- 例如，在类中定义了`def __str__(self): return(attr1...)`后，使用print(object1)时，python就会调用`__str__`函数，返回由该函数定义的字符串，
				- 运算符的重新定义
					- 在自定义的类中，可以对基本运算符（+、-、*等）和关系运算符（<、>、==等）的功能进行重新定义，
					- 一般目的为使其更符合类中的元素的形式，并非对运算符的功能进行彻底的重新规划，
					- 例如，`def __add__(self, attr1):`可以重新定义加号的作用；重新定义后，对类中的实例，+运算符就会按照自定义的函数起作用，
					- 直接替换原有运算符的功能，可能导致需要利用基本运算符时出错，应全面考虑不同的情况，并分别规定不同的运算方式，
		- 类变量
			- 部分类可能需要多次调用某个常量，如“圆”类可能需要经常调用\pi的值，
			- 可以在类中定义对应的常量，即var1 = num1，
			- 类中的方法或是类外应用变量时，都需要用点标记法声明Class1.var1，
			- 不能通过对实例使用点标记法更改类变量，即object1.var1 = str1只会给object1增加一个新的属性var1，并不会对类变量产生影响；但可以通过对类使用点标记法更改类变量，即使用Class1.var1 = str2，
		- 其它
			- 引用其它文件
				- 编写方法时可能需要引入其它的文件（或未引入的库）中的函数，这种情况下一般不在方法中加入引入语句import，而是在库的外部先写出引用语句，
			- 将类用作属性
				- 对于较复杂的物体，其拥有属性和方法可能很多，这种情况下可以将类的一部分作为一个独立的类提取出来，并用作类的一个属性，
			- 代码重构
				- 类并不一定必须是现实世界中已有的具体物体，也可能为部分重复代码的抽象总体；
				- 例如，某些程序可能会有多个函数对部分变量（一般为全局变量）进行多次调用，而重复的调用可能会导致输出混乱。此时，可以将这些变量封装到一个类中，并将函数转化为方法；这是简化代码的一种方式，
	- 继承（Inheritance）
	  collapsed:: true
		- 引入
			- 在现实世界中，很多事物可以进一步分类；例如，汽车可以分为电动车、汽油车两类，两类汽车有很多汽车的相同点，但是在动力、续航等性质上仍有着本质性的，不能等同的区别；因此，在这种情况下使用继承是一种较好的方式，
		- 定义
			- 在现有类的基础上定义新的类，原有的类称为父类，而新类称为子类，
		- 应用
			- 然而，对于某些抽象的问题，继承也可能会使得程序更加难读，即与一个方法相关的代码可能被分散在几个模块之中 ，
			- 应对每个类和属性做出完整的注释；此外，也可以在方法的开始处使用print函数`print(object1.func1)`追踪具体执行的方法来自于哪一个类，
		- 子类的设置
			- class函数`class Class2(Class1):`
			- 方法与属性
				- init方法
				  collapsed:: true
					- 定义def __init__(self, attr1, attr2, attr3...):，
					- 组成
						- super方法super().__init__(attr1, attr2...)，可以继承父类中对属性的定义，而无需重新定义属性，
						- 定义子类的特有属性self.attr3 = attr3，
				- 方法
				  collapsed:: true
					- 子类可以直接继承父类的所有方法（即不需要额外的函数语句）；然而，若不在init中继承属性，则依赖于父类中的属性的方法仍然不能使用，
					- （子类也可以直接继承父类中定义的所有变量，但应注意变量的合理命名），
					- 继承了父类的属性后，就可以在子类的方法中对父类属性进行修改，
				- 方法覆盖
				  collapsed:: true
					- 若在新的类中重新定义部分方法，则新的定义会覆盖原有的类中的方法的定义；未定义的其他方法则不受影响，
					- 在覆盖方法时，应当使新方法的接口与旧方法保持一致，包括接受相同的参数、返回相同的类型等；这可以使能够用于父类的对象的方法，一定可以用于子类，
	- 调试
	  collapsed:: true
		- 类的检查
			- class属性
			  collapsed:: true
				- 使用`object1.__class__`可以返回一个type对象type1，描述object1所属的类，
				  id:: 624ae404-2956-4020-a1f4-9e68a8858cbc
				- 使用`type1.__name__`可以返回一个字符串，描述object1的类；而`type1.__bases__`则可以返回一个元组，描述object1所属的类继承的父类，
			- isinstance函数
			  collapsed:: true
				- 函数`isinstance(arg1, Class1)`返回一个布尔值，描述arg1是否为Class1中的实例，
				- python中的“类”的含义十分广泛，即int、list、tuple等数据结构也为一个“类”，
			- issubclass函数
			  collapsed:: true
				- 函数isinstance(Class1, Class2)返回一个布尔值，描述Class1是否为Class2的子类，
		- 属性检查
			- hasattr(object1, attr1)返回一个布尔值，可以用于检测对象是否拥有某个属性，
			- vars(object1)返回一个字典（属性名称：属性取值），可用于查看对象的所有属性；而vars(Class1)则可查看类的所有属性和类变量，
	- 数据类型即对象
	  collapsed:: true
		- Python的类型是动态确定的，即同一变量的数据类型会随着程序运行而变化，而不需要事先声明，
		- python的一个思想为“所有”变量均为“对象”，即所有的变量都由对应的类定义，
			- 例如，字符串属于str类，布尔值属于bool类，而str和bool则属于type类，
		- “鸭子类型”
			- 相比于Java等对数据结构和类有严格的要求的语言，python更希望强调“实用性”，即通过灵活的应用数据结构和类达到编程的目的，而不是必须遵循严格的定义，执行严格的检查，
			- 因此，python中引入了很多异常类型，以保证程序出现错误时解释器可以发现并中断程序；相比之下，Java、C等语言则没有规定这样多的异常，因此在编写时就需要尽量保证程序不出错误，
- 模块（module）
	- 定义
	  collapsed:: true
		- 相互关联的函数，类和变量的组合，一般以脚本文件file.py的形式储存，
		- 若需要在新的程序中使用这些函数，可以直接利用import函数导入模块，而无需再次编写函数代码，
	- 基本操作
	  collapsed:: true
		- 导入
			- import函数
				- python内部的函数模块和非内置的包含python代码的文件file.py都可以利用import函数导入，
				- 如果模块已经被导入，则再次试图导入模块不会产生行为，即python不会重新读取模块，
					- 若模块在运行过程中被修改，修改内容不会被同步更新，
					- 可以利用importlib库中的reload方法重新导入模块importlib.reload()，但可能导致某些问题，
					- 最好的方式为重启解释器并重新导入模块，
			- import as函数
				- 可以改写（一般为简写）模块的名称import numpy as np，便于后续使用，
				- 使用模块中的函数时也必须用新指定的名称，模块的原名称无法再使用，
			- from import函数
				- 在需要导入某个频繁使用的对象时，可以通过from module import object将模块中的指定对象名称直接导入代码，再次使用该对象时就无须再带模块名称；
					- 然而，对于较长的程序，这样的语句可能使程序变得不容易理解，
					- 此外，若两个模块都定义了同一个对象名则会发生命名冲突，且第二个模块中的名称将会替换第一个模块中的名称，
				- Python中用前置下划线_func表示私有名称，from import函数不会导入这些语句，
		- 模块使用
			- 模块函数
				- 使用模块中的函数需要带上模块名称，如numpy.sin()，
				- 由于函数与具体的模块绑定，因此可以使用不同模块中的同一名称函数，如numpy.sin()和math.sin()的使用都是合法的，
				- 模块中的函数可以直接访问同一模块内定义的其他对象，不需要带上模块名，
			- 模块类
				- 使用模块中的类与类似使用函数，即同样需要带上模块名称，如module.class()，
		- 脚本模式运行
			- 一般情况下，我们希望模块被导入后只是增加一些新的函数的定义，但并不运行或输出结果；
			- 可以利用if __name__ == '__main__':语句设置作为模块的程序；若程序以脚本的形式运行，则if语句返回True，语句后的代码将被执行；而当程序作为模块被导入时，if语句返回False（此时__name__的值为模块的名称，不再为main），从而代码会被跳过，
		- 模块位置
			- sys模块中的sys.path语句会给出python解释器在执行import语句时会搜索的模块路径，
			- 以交互模式执行Python时，sys.path的第一个元素为空字符串，Python会将其视为首先在当前目录中搜索模块，
			- 然而，对于脚本模式的操作，上述方法一般不再可行；可以尝试将Python程序要用到的全部模块， 都和程序放在同一目录中；或新建目录用于保存自己的模块，并修改sys.path变量，使之包含该新建目录，
			- 细节可以参考Python Library Reference中关于site模块的介绍，
	- 编写模块
	  collapsed:: true
		- 理论上，“编写模块”不是一个独立的编程过程，编写模块主要指的是编写具体的函数或具体的类，
		- 一般模块最开始为三引号标记的注释语句，用于描述模块所包含的函数的类型，
			- 添加的注释语句可以使用__doc__方法访问，
- 包（package）
	- 定义
	  collapsed:: true
		- 相互关联的模块的组合；相比模块， 包可以更好地组织“大型”的代码集，
		- 若需要在新的程序中使用这些函数，可以直接利用import函数导入模块，而无需再次编写函数代码，
		- （前提条件）：python规定，只有包含`__init__.py`文件的目录才会被识别为包，因此，一般python的包中的所有目录都会包含一个`__init__.py`文件，
	- 基本操作
	  collapsed:: true
		- import语句
			- 类似模块，可以使用import语句导入包，
			- python规定，导入包的顶级模块并不会加载其全部子模块，例如import matplotlib并不会同时导入matplotlib.pyplot，
			- 可以通过输入具体的模块名称判断模块是否被导入，
		- （类似外部模块，包内的文件同样需要用import语句才能访问包内其他文件中的对象），
		- （__all__属性）
- 库（library）
	- python中的标准库
	  collapsed:: true
		- 数据类型库
			- 字符串库（string，re，struct），
			- 数值库（numbers，math，random），
			- 其它数据库（array，queue，collections）
		- 文件库
			- pathlib，filecmp，pickle，
		- 操作系统库
			- os，time，io，logging，
		- 调试库
			- doctest，pdb，profile，trace，
		- 互联网库
			- socket，email，http.server，
	- pip方法
	  collapsed:: true
		- 可以在cmd（powershell）中使用pip语句pip install package安装互联网上发行的库，
		- Python文档的“Installing Python Modules”提供了更多信息，
	- （虚拟环境）
	- PyPI（Python Package Index）
	  collapsed:: true
		- PyPI是Python代码的官方库，包含了适用于各个Python版本的包，
		- PyPI中的包默认按照添加日期和名称排列，但可通过类别进行搜索，
- 程序（py文件）
	- 脚本模式与交互模式
	  collapsed:: true
		- 交互模式：在解释器中直接输入代码并运行，
		- 脚本模式：将代码保存到文件内，运行解释器并执行脚本，
		- 脚本模式不会展示结果，而是需要利用print函数等语句才会显示结果，
	- 临时程序与长期程序
	  collapsed:: true
		- 临时程序：运行一段时间并输出结果，运行结束后不保存数据；再次运行时仍以全新状态开始，
		- 长期程序：维持运行状态，将部分数据记录在存储设备中（例如对硬盘上的文件进行读写）；再次运行时从上次中断的地方继续，
	- 运行python脚本
	  collapsed:: true
		- 命令行方式（Windows）
			- 首先用cd C:\Users\更改powershell的运行目录到脚本文件所在的目录，若目录为当前路径的子目录，则可直接使用cd folder语句（由于Windows的命名原则，目录语句可以不区分大小写），
			- 使用python file.py即可运行对应文件，
	- 接受命令行参数
	  collapsed:: true
		- sys模块中的sys.argv方法可以接受命令行中传入的参数（一个或多个），并将其存储为一个字符串组成的列表['file.py', 'arg1', 'arg2'...] ，
		- （输入、输出的重定向）、（argparse模块的应用）、（fileinput模块的应用），
	- main函数
	  collapsed:: true
		- 对于较复杂的算法，最好将其写为多个函数和主控函数main()的组合，
		- 因为main函数所包含的主要为其他函数，所以一般将main函数写在末尾 ，
	- 脚本模式运行
	  collapsed:: true
		- 可以使用if __name__ == '__main__':语句设置条件；
		- 若程序以脚本的形式运行，则if语句返回True，语句后的代码将被执行；而当程序作为模块被导入时，if语句返回False（此时__name__的值为模块的名称，不再为main），从而语句后的代码会被跳过，
- 帮助
	- help()函数可以返回输入参数的帮助，
	- dir()函数可以列出特定模块中的全部对象，
	- globals()函数可以显示与对象相关联的值，
- 调试
	- 错误
	  collapsed:: true
		- 类型
			- 语法错误：python有规定的语法规则，若语法出错则会报错并停止运行；需要多次练习以熟悉规则，形成习惯，
			- 语义错误：程序可以被执行，但返回的并非程序员想要的结果；可能是因为语法错误，或者函数调用不当，
			- 运行错误
		- 错误信息
			- python会返回错误信息，但是只能返回错误的最后一步；而最后一句出错可能并非语法出错，而是上面的语句出现了语义错误；应该仔细排查变量与函数的设置，分析错误原因，
		- 语义错误的可能原因
			- 函数获得的参数有问题，
				- 可以增加一条print语句，打印出函数获得的参数及其类型，便于判断指定的参数，
			- 函数的中间值或者返回值有问题，
				- 可以在return语句之前增加print语句，便于分析返回值；
				- 可以试着用较为简单的取值检查对应结果是否正确，
			- 函数调用参数和返回值的方式有问题，
	- 对分调试
	  collapsed:: true
		- 可以试着将代码分为两部分，寻找一个可以检查的中间值，利用return、print语句验证代码是否运行良好，
		- 如果中间点检查出错了，那么就说明程序的前半部分存在问题。如果没问题，则说明是后半部分出错了，
		- 理论上，这样可以减少调试的数量；其关键在于合理的对代码进行分割，寻找最容易出错误的地方，
	- 参数错误
	  collapsed:: true
		- 一般情况下，函数所需求的输入参数只在一定范围内才是符合现实的（或符合python运算规律的），但是最初编写函数时可能会忽略这一点，
		- 可以增加额外的校验函数，判断输入的数值是否合法，
		- assert语句可以检查给定的函数，并在失败的情况下返回异常，
		- 面对参数错误时，应注意调用的对象本身也被视为一个参数，
	- 接口与实现分离
	  collapsed:: true
		- 为了使软件更容易维护，一般采取接口与实现分离的方式，
		- 对于对象，这意味着一个类提供的方法不应该依赖对象的属性的形式，
-
- 其它操作
	- 电脑操作
	  collapsed:: true
		- 路径选择
			- os模块
				- 查看路径：os.getcwd()函数可以返回当前（绝对）路径，
					- 相对（relative）路径：受运行环境的目录影响，且随环境路径的改变而变化，
					- 绝对（Absolute）路径：电脑中文件的路径，与当前环境的目录无关，
				- 改变路径：可以使用os.chdir('c:\user')函数，
					- 由于Windows的命名原则，目录语句可以不区分大小写，
				- 新建文件夹：os.makedirs('folder') 会在当前目录新建空文件夹folder，
				- 遍历文件：os.walk('c:\user')函数会遍历给定目录下的所有文件，返回一个生成器对象，
		- pathlib模块
			- 查看路径：pathlib.Path()函数可以返回当前（相对）路径，
		- 中断程序运行
			- 采用Ctrl+C快捷键可以强制终止程序执行，显示为“KeyboardInterrupt”，且不会关闭shell，
			- 也可以尝试直接关闭shell进程，
		- input函数
			- str = input("arg")函数接受一个可选参数arg，输出arg和输入框，并将用户的输入存储为到字符串str中，
		- 文件操作
			- 打开文件
				- open('file.txt', mode = 'r')可以打开文件，返回一个file变量；
					- 可选参数mode默认为'r'，即可读模式，
						- mode = 'w'可以写入文件（如果文件不存在，那么将创建一个新的文件；若文件已经存在，用写入模式打开它将会清空原来的数据，并从新开始），
						- mode = 'a'可以将需要写入的数据附加到原文件后，而不会清空原来的数据，
					- open语句并不会直接生成变量，可以open语句生成的file变量赋值给一个变量file1，并对变量进行操作，
				- 文件编码
					- open函数提供了可选参数errors，用于处理非ASCII字符，默认参数为strict（遇到非ASCII字符时报错，并停止程序），
					- 此外，ignore参数会忽略这些字符，而backslashreplace参数则会用用反斜杠转义序列替换字符，
				- with关键字（上下文编辑器）
					- 语句with open('file.txt', 'r') as file1:综合了三种操作，
						- 打开file.txt并将其赋值给变量file1，执行冒号后的语句，关闭文件，
					- 注意事项
						- with关键字后的open语句同样可以接受可选参数，
						- 若不存在file.txt，则with语句会新生成file.txt文件，
						- with关键字在执行完语句后会关闭文件，若需要进一步的编辑，则需要重新打开文件，
						- 进一步的信息可以查看标准库中contextlib模块的文档， 包括如何创建上下文管理器， 以及对它的各种操控方式，
			- 文件方法
				- 读取
					- file1.readlines()可以将文件转换为列表，
					- file1.readline()会读取文件的第一行，返回一个字符串，下次调用则会读取第二行，以此类推，
					- file1.read()可以将文件转换为一个字符串，
				- 写入
					- file1.write('string')可以将字符串（只能为字符串）输入至文件中，并返回被写入字符的个数，
						- write方法只能用于写入模式('w'或'a')打开的文件，
						- write方法默认不会换行，可以加入字符'\n'实现换行操作，
						- 可以用str函数将其它值转换为字符串，
					- file1.writelines()可以将字符串列表（列表中的元素必须都为字符串）按字符串逐个输入至文件中，不产生返回值，
				- file1.close()方法可以关闭文件；若不关闭，则文件直到程序结束时才会关闭，
			- struct模块可以用于读取二进制数据，
			- pickle模块和shelve模块可以用于保存对象，
		- json模块
			- json.dump(var1, file1)将var1中的数据写入file1中，不产生返回值，
			- json.load(file1)可以读取并返回file1中的数据，
		- sys模块
		- csv模块
	- 网络操作
	  collapsed:: true
		- 获取（fetching）网络数据
			- 方式
				- ftp服务器
				- sftp协议
				- http/https协议
				- api
			- 工具
				- ftplib模块
				- requests库
			- 数据形式
				- json
					- 数据结构
						- 基本结构：字符串，数值，布尔值，null值，
						- 复杂结构
							- 对象（object），类似字典的键值对；“键”只能为字符串，“值”可以为数字等其他数据，
							- 数组（array），类似列表，
							- 以上两种数据结构是json的核心，这使得json可以很便捷的通过网络传递信息，
					- 工具
						- json模块
						- requests模块
					- 修改
						- 美观输出（pretty printing）：由于格式简单，json的信息排版可能较为混乱，可以使用pprint模块改善其排版，
				- xml
					- 数据结构
						- xml的数据编排较为复杂，一般以尖括号开始和结束，类似<title> <information...> </title>，并利用缩进来区分不同组的信息，
					- 工具
						- xmltodict库
		- 抓取（scraping）网络数据
	- 数据科学
	  collapsed:: true
		- 数据交互
			- Jupyter记事本
		- 数据分析
			- pandas库
		- 数据库
			- 关系数据库（relational databases）：SQlite，MySQL，PostgreSQL
			- NoSQL数据库：Redis，MongoDB，
-
-
-
-
-
-
- 其它
	- 编程思想
	  collapsed:: true
		- 迭代思想
			- 不同于人类，计算机很擅长重复执行同样的简单语句，
			- 迭代
				- 迭代的关键在于确定合理的起点与终点，在构造迭代语句时，可以先将进行迭代需要的元素一一列出，
				- 一般会发生变化的元素需要被定义为参数；作为参照的元素则可以直接用函数表示出来，而无需引入额外参数，
					- 在迭代语句中，迭代的次数是极为重要的变量，应该尽量详细的分析迭代的多种可能结果，从而对结果进行一个更好的抽象，并用变量描述迭代的次数，
					- 可以试着将简化或推广场景（例如从一个字母、固定次数引申到任意字母、次数）以辅助思考，
					- 不应强求一次得出结论， 面临的问题较为复杂时，可以先写出简单但可以执行的重复语句，再试着做出简化，
			- 递归
				- 函数可以调用参数和函数，也可以调用自己，
				- 若递归达不到基础情形，则会导致无限递归，一般的编程语言会设置无限递归的最大深度，并在达到时报告错误，
		- 解题方式
			- 同数学类似，试着解决编程问题时也可以采取两条主线，即从已知推导问题、从问题反推回已知，
			- 应试着首先找出一个可以的解决方案，再去简化代码，
		- 分解复杂问题
			- 复杂的问题往往可以分为多个步骤解决，因此在面临较为复杂的问题时，可以先试着将问题分解为几个特殊化的小问题，并逐个编写特定函数解决，每次只增加和测试少量代码；而不是直接编写一个完整的复杂的函数；
			- 在设计函数时应使函数具有可迁移性，即可以用在别的应用之中，
			- 应该从一个能够正常运行的程序开始，每次只做一些小改动，并同步进行调试，
		- 执行流程
			- 流程总是从程序的第一条语句开始，自顶向下，每次执行一条语句，
			- 可以试着画图流程图来分析函数执行的顺序，理清逻辑，
				- __main__表示最上层堆栈，可以调用其它函数，其他函数之间也会相互调用，
				- __main__管理函数之外的变量，而每个函数的变量都只局限于函数内部，只有相互调用的函数之间才会有变量的传递，
				- 如果函数调用时发生错误，Python 会打印出错函数的名字以及调用它的函数的名字，以及调用后面这个函数的名字，一直追溯到__main__为止。
		- 计算机程序的图解
			- 仅在大脑中推算程序的运行模式可能会显得抽象和难以理解，可以利用图解分析计算机程序的具体运行模式，帮助理清程序运行的逻辑，
			- 栈图
				- 描述程序运行的步骤、状态，
			- 对象图
				- 描述某个对象在运行时的取值的变化，
			- 类图
				- 描述类与类之间的关系，如引用、继承等，
		- 函数的精简
			- 函数应尽可能简洁，避免让使用者处理不必要的细节，
			- 函数的实质是对多个类似的或重复性的行为的抽象与简化，可以通过画出函数运行的栈图来找到优化函数的方式，并试着通过复合语句精简程序；
			- 部分函数可能会执行类似的行为，可以从现有函数中分离出表述相似行为的语句，简化新的函数的编写，
		- 搜索
			- 搜索的一般模式为遍历给定序列， 并在找到需要的东西时返回，
			- 搜索一般需要for、while语句的组合应用，
			- 应注意函数语句中的参数也需要用return函数返回输出值，
		- 函数式编程
			- 纯函数：接受一个对象，并返回新的值，不改变输入的对象；
			- 修改器：接受一个对象，并对对象中的属性进行部分修改以符合实际（或方便进一步运算），一般不返回值，
			- 一般情况下，不建议对输入对象的原始属性进行修改；可以试着寻找需要使用修改器的深层原因，并利用纯函数方式解决，
	- 程序的组成
	  collapsed:: true
		- 多个输入数据、参数和函数的有序组合（函数需要调用指定的参数，可以是人为给定，或是其他函数的输出）,
		- 基本步骤：输入、执行（检验）、输出、重复，
-
- [[Data_science]]