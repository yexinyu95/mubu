- 绪论
	- 基本概念
	- 算法
	- 算法评价
- 递归（Recursive）
	- 定义
	  collapsed:: true
		- 包括两个步骤，
		- 基础步骤：定义初始条件P(1)，
		- 递归步骤：定义由P(k)求出P(n)的规则，其中1≤k≤n，
	- 结构归纳法
	  collapsed:: true
		- 基础步骤：证明基础步骤为真，
		- 假设步骤：假设第一次递归得到的命题为真，
		- 归纳步骤：证明后续递归得到的命题也为真，
	- 广义归纳法
	  collapsed:: true
		- 应用对象：基于正整数N的关系集合（N \times N），即数组(m, n)的命题P(m，n)，
		- （证明）
		  collapsed:: true
			- 基于关系集合的字典顺序和良序性，
	- 递归与迭代
		- 递归(Recursion)算法
		  collapsed:: true
			- 一般为由上到下（初始条件），
			- 即根据给定的值，根据递推公式逐个反推前一步，直到初始条件，
			- 对于可以递归定义的序列，递归算法易于实现，也较容易理解；然而，递归算法一般需要的资源更多，即运算效率更低，
		- 迭代(Iteration)算法
		  collapsed:: true
			- 一般为由下（初始条件）到上，
			- 即根据初始条件，根据递推公式逐个求解下一步的取值，
			- 再将下一步的取值当作初始条件，继续计算，直到要求的取值，
			- 迭代算法一般运算效率更高，然而一般需要人为对算法进行分析和推导，相对递归算法而言更难以实现，
		- 示例：Fibonacci数列的计算
			- 输入：正整数n
			- 递归算法
			  collapsed:: true
				- 由递推公式，f(n) = f(n - 1) + f(n - 2)，
				- 求解f(n - 1)，为f(n - 2) + f(n - 3)，
				- 再求解f(n - 2) …
				- 直到初始条件f(0) = 0，f(1) = 1，
			- 迭代算法
				- 由初始条件f(0) = 0和f(1) = 1开始，
				- 设变量x = 0，y = 1，
				- for(i = 1 ; i < n - 1; i++)
					- z = x + y;
					  collapsed:: true
						- 将算出来的z当作下一次循环的初始条件 ，继续循环，
					- x = y;
					- y = z;
			- 输出：Fibonacci数列的第n项
- 线性表
	- 定义
	- 顺序表示
	- 链式表示
- 栈，队列，数组
	- 栈
	- 队列
	- 数组
- 串
	- 定义
	- 模式匹配
- 树与二叉树
	- 树
	- 二叉树
	- 树的遍历
	- 森林
	- 应用
- 图
	- 概念
	- 图的存储
	- 图的遍历
	- 图的应用
- 查找
	- 概念
	- 顺序查找和折半查找
	- 树型查找
	- B树
	- 散列表
- 排序
	- 概念
	- 插入排序
	- 交换排序
	- 选择排序
	- 归并排序与基数排序
	- 内部排序算法的比较
	- 外部排序
-
- 其它
-
- [[C]]
- [[C++]]
- [[图论]]
- [[数理逻辑]]
- [[408考研经验]]
- [[Science]]